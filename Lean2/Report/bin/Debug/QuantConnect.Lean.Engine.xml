<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QuantConnect.Lean.Engine</name>
    </assembly>
    <members>
        <member name="T:QuantConnect.Lean.Engine.AlgorithmManager">
            <summary>
            Algorithm manager class executes the algorithm and generates and passes through the algorithm events.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.State">
            <summary>
            Publicly accessible algorithm status
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.AlgorithmId">
            <summary>
            Public access to the currently running algorithm id.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.TimeLimit">
            <summary>
            Provides the isolator with a function for verifying that we're not spending too much time in each
            algorithm manager time loop
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.QuitState">
            <summary>
            Quit state flag for the running algorithm. When true the user has requested the backtest stops through a Quit() method.
            </summary>
            <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.Quit(System.String)"/>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.DataPoints">
            <summary>
            Gets the number of data points processed per second
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.#ctor(System.Boolean,QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.AlgorithmManager"/> class
            </summary>
            <param name="liveMode">True if we're running in live mode, false for backtest mode</param>
            <param name="job">Provided by LEAN when creating a new algo manager. This is the job
            that the algo manager is about to execute. Research and other consumers can provide the
            default value of null</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.Run(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.ISynchronizer,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Lean.Engine.Server.ILeanManager,QuantConnect.Lean.Engine.Alpha.IAlphaHandler,System.Threading.CancellationToken)">
            <summary>
            Launch the algorithm manager to run this strategy
            </summary>
            <param name="job">Algorithm job</param>
            <param name="algorithm">Algorithm instance</param>
            <param name="synchronizer">Instance which implements <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer"/>. Used to stream the data</param>
            <param name="transactions">Transaction manager object</param>
            <param name="results">Result handler object</param>
            <param name="realtime">Realtime processing object</param>
            <param name="leanManager">ILeanManager implementation that is updated periodically with the IAlgorithm instance</param>
            <param name="alphas">Alpha handler used to process algorithm generated insights</param>
            <param name="token">Cancellation token</param>
            <remarks>Modify with caution</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.SetStatus(QuantConnect.AlgorithmStatus)">
            <summary>
            Set the quit state.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.ProcessVolatilityHistoryRequirements(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Helper method used to process securities volatility history requirements
            </summary>
            <remarks>Implemented as static to facilitate testing</remarks>
            <param name="algorithm">The algorithm instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.AddMethodInvoker``1(QuantConnect.Interfaces.IAlgorithm,System.Collections.Generic.Dictionary{System.Type,Fasterflect.MethodInvoker},System.String)">
            <summary>
            Adds a method invoker if the method exists to the method invokers dictionary
            </summary>
            <typeparam name="T">The data type to check for 'OnData(T data)</typeparam>
            <param name="algorithm">The algorithm instance</param>
            <param name="methodInvokers">The dictionary of method invokers</param>
            <param name="methodName">The name of the method to search for</param>
            <returns>True if the method existed and was added to the collection</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.HandleDelistedSymbols(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Data.Market.Delistings,System.Collections.Generic.List{QuantConnect.Data.Market.Delisting})">
            <summary>
            Performs delisting logic for the securities specified in <paramref name="newDelistings"/> that are marked as <see cref="F:QuantConnect.DelistingType.Delisted"/>.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.ProcessDelistedSymbols(QuantConnect.Interfaces.IAlgorithm,System.Collections.Generic.List{QuantConnect.Data.Market.Delisting})">
            <summary>
            Performs actual delisting of the contracts in delistings collection
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.HandleSplitSymbols(QuantConnect.Data.Market.Splits,System.Collections.Generic.List{QuantConnect.Data.Market.Split})">
            <summary>
            Keeps track of split warnings so we can later liquidate option contracts
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.ProcessSplitSymbols(QuantConnect.Interfaces.IAlgorithm,System.Collections.Generic.List{QuantConnect.Data.Market.Split},System.Collections.Generic.List{QuantConnect.Data.Market.Delisting})">
            <summary>
            Liquidate option contact holdings who's underlying security has split
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.EndTimeIsInNativeResolution(QuantConnect.Data.SubscriptionDataConfig,System.DateTime)">
            <summary>
            Determines if a data point is in it's native, configured resolution
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.CreateTokenBucket(QuantConnect.Packets.LeakyBucketControlParameters)">
            <summary>
            Constructs the correct <see cref="T:QuantConnect.Util.RateLimit.ITokenBucket"/> instance per the provided controls.
            The provided controls will be null when
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.IIsolatorLimitResultProvider"/> that tracks the algorithm
            manager's time loops and enforces a maximum amount of time that each time loop may take to execute.
            The isolator uses the result provided by <see cref="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.IsWithinLimit"/> to determine if it should
            terminate the algorithm for violation of the imposed limits.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.AdditionalTimeBucket">
            <summary>
            Gets the additional time bucket which is responsible for tracking additional time requested
            for processing via long-running scheduled events. In LEAN, we use the <see cref="T:QuantConnect.Util.RateLimit.LeakyBucket"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.#ctor(QuantConnect.Util.RateLimit.ITokenBucket,System.TimeSpan)">
            <summary>
            Initializes a new instance of <see cref="T:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager"/> to manage the
            creation of <see cref="T:QuantConnect.IsolatorLimitResult"/> instances as it pertains to the
            algorithm manager's time loop
            </summary>
            <param name="additionalTimeBucket">Provides a bucket of additional time that can be requested to be
            spent to give execution time for things such as training scheduled events</param>
            <param name="timeLoopMaximum">Specifies the maximum amount of time the algorithm is permitted to
            spend in a single time loop. This value can be overriden if certain actions are taken by the
            algorithm, such as invoking the training methods.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.StartNewTimeStep">
            <summary>
            Invoked by the algorithm at the start of each time loop. This resets the current time step
            elapsed time.
            </summary>
            <remarks>
            This class is the result of a mechanical refactor with the intention of preserving all existing
            behavior, including setting the <code>_currentTimeStepTime</code> to <see cref="F:System.DateTime.MinValue"/>
            </remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.StopEnforcingTimeLimit">
            <summary>
            Stops this instance from tracking the algorithm manager's time loop elapsed time.
            This is invoked at the end of the algorithm to prevent the isolator from terminating
            the algorithm during final clean up and shutdown.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.IsWithinLimit">
            <summary>
            Determines whether or not the algorithm time loop is considered within the limits
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.RequestAdditionalTime(System.Int32)">
             <summary>
             Requests additional time to continue executing the current time step.
             At time of writing, this is intended to be used to provide training scheduled events
             additional time to allow complex training models time to execute while also preventing
             abuse by enforcing certain control parameters set via the job packet.
            
             Each time this method is invoked, this time limit manager will increase the allowable
             execution time by the specified number of whole minutes
             </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.TryRequestAdditionalTime(System.Int32)">
             <summary>
             Attempts to requests additional time to continue executing the current time step.
             At time of writing, this is intended to be used to provide training scheduled events
             additional time to allow complex training models time to execute while also preventing
             abuse by enforcing certain control parameters set via the job packet.
            
             Each time this method is invoked, this time limit manager will increase the allowable
             execution time by the specified number of whole minutes
             </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.IsOutOfTime(System.TimeSpan@)">
            <summary>
            Determines whether or not the algorithm should be terminated due to exceeding the time limits
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmTimeLimitManager.GetCurrentTimeStepElapsed">
            <summary>
            Gets the current amount of time that has elapsed since the beginning of the
            most recent algorithm manager time loop
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension">
            <summary>
            Manages alpha charting responsibilities.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.AlphaAssets">
            <summary>
            The string name used for the Alpha Assets chart
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.SampleInterval">
            <summary>
            Gets or sets the interval at which alpha charts are updated. This is in realtion to algorithm time.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.#ctor(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension"/> class
            </summary>
            <param name="algorithm">The algorithm instance. This is only used for adding the charts
            to the algorithm. We purposefully do not save a reference to avoid potentially inconsistent reads</param>
            <param name="statisticsManager">Statistics manager used to access mean population scores for charting</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.Step(System.DateTime)">
            <summary>
            Invokes the manager at the end of the time step.
            Samples and plots insight counts and population score.
            </summary>
            <param name="frontierTimeUtc">The current frontier time utc</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.InitializeForRange(System.DateTime,System.DateTime,System.DateTime)">
            <summary>
            Invoked after <see cref="M:QuantConnect.Interfaces.IAlgorithm.Initialize"/> has been called.
            Determines chart sample interval and initial sample times
            </summary>
            <remarks>
            While the algorithm instance is provided, it's highly recommended to not maintain
            a direct reference to it as there is no way to guarantee consistence reads.
            </remarks>
            <param name="algorithmStartDate">The start date of the algorithm</param>
            <param name="algorithmEndDate">The end date of the algorithm</param>
            <param name="algorithmUtcTime">The algorithm's current utc time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.OnInsightGenerated(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            Handles the <see cref="E:QuantConnect.Interfaces.IAlgorithm.InsightsGenerated"/> event.
            Keep daily and total count of insights by symbol
            </summary>
            <param name="context">The newly generated insight analysis context</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.OnInsightClosed(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            NOP - Charting is more concerned with population vs individual insights
            </summary>
            <param name="context">Context whose insight has just completed analysis</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.OnInsightAnalysisCompleted(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            NOP - Charting is more concerned with population vs individual insights
            </summary>
            <param name="context">Context whose insight has just completed analysis</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.ChartingInsightManagerExtension.PopulateChartWithSeriesPerSymbol(System.Collections.Generic.Dictionary{QuantConnect.Symbol,System.Int32},QuantConnect.Chart,QuantConnect.SeriesType,System.DateTime)">
            <summary>
            Creates series for each symbol and adds a value corresponding to the specified data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler">
            <summary>
            Default alpha handler that supports sending insights to the messaging handler, analyzing insights online
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.CancellationToken">
            <summary>
            The cancellation token that will be cancelled when requested to exit
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.IsActive">
            <summary>
            Gets a flag indicating if this handler's thread is still running and processing messages
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.RuntimeStatistics">
            <summary>
            Gets the current alpha runtime statistics
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.AlgorithmId">
            <summary>
            Gets the algorithm's unique identifier
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.LiveMode">
            <summary>
            Gets whether or not the job is a live job
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.Job">
            <summary>
            Gets the algorithm job packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.Algorithm">
            <summary>
            Gets the algorithm instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.MessagingHandler">
            <summary>
            Gets the confgured messaging handler for sending packets
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.InsightManager">
            <summary>
            Gets the insight manager instance used to manage the analysis of algorithm insights
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
            <summary>
            Initializes this alpha handler to accept insights from the specified algorithm
            </summary>
            <param name="job">The algorithm job</param>
            <param name="algorithm">The algorithm instance</param>
            <param name="messagingHandler">Handler used for sending insights</param>
            <param name="api">Api instance</param>
            <param name="transactionHandler">Algorithms transaction handler</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.AddInsightManagerCustomExtensions(QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension)">
            <summary>
            Allows each alpha handler implementation to add there own optional extensions
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.OnAfterAlgorithmInitialized(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Invoked after the algorithm's Initialize method was called allowing the alpha handler to check
            other things, such as sampling period for backtests
            </summary>
            <param name="algorithm">The algorithm instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.ProcessSynchronousEvents">
            <summary>
            Performs processing in sync with the algorithm's time loop to provide consisten reading of data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.Exit">
            <summary>
            Stops processing and stores insights
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.StoreInsights">
            <summary>
            Save insight results to persistent storage
            </summary>
            <remarks>Method called by the storing timer and on exit</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.CreateInsightManager">
            <summary>
            Creates the <see cref="P:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.InsightManager"/> to manage the analysis of generated insights
            </summary>
            <returns>A new insight manager instance</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.AlphaResultPacketSender">
            <summary>
            Encapsulates routing finalized insights to the messaging handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.AlphaResultPacketSender.OnInsightAnalysisCompleted(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            Enqueue finalized insights to be sent via the messaging handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.DefaultAlphaHandler.AlphaResultPacketSender.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension">
            <summary>
            Manages alpha statistics responsbilities
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.Statistics">
            <summary>
            Gets the current statistics. The values are current as of the time specified
            in <see cref="P:QuantConnect.AlphaRuntimeStatistics.MeanPopulationScore"/> and <see cref="P:QuantConnect.AlphaRuntimeStatistics.RollingAveragedPopulationScore"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.RollingAverageIsReady">
            <summary>
            Gets whether or not the rolling average statistics is ready
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.#ctor(QuantConnect.Interfaces.IAccountCurrencyProvider,System.Decimal,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension"/> class
            </summary>
            <param name="accountCurrencyProvider">The account currency provider</param>
            <param name="tradablePercentOfVolume">Percent of volume of first bar used to estimate the maximum number of tradable shares. Defaults to 1%</param>
            <param name="period">The period used for exponential smoothing of scores - this is a number of insights. Defaults to 100 insight predictions.</param>
            <param name="requireRollingAverageWarmup">Specify true to force the population average scoring to warmup before plotting.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.OnInsightGenerated(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            Handles the <see cref="E:QuantConnect.Interfaces.IAlgorithm.InsightsGenerated"/> event
            Increments total, long and short counters. Updates long/short ratio
            </summary>
            <param name="context">The newly generated insight context</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.OnInsightClosed(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            Computes an estimated value for the insight. This is intended to be invoked at the end of the
            insight period, i.e, when now == insight.GeneratedTimeUtc + insight.Period;
            </summary>
            <param name="context">Context whose insight has just closed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.OnInsightAnalysisCompleted(QuantConnect.Algorithm.Framework.Alphas.Analysis.InsightAnalysisContext)">
            <summary>
            Updates the specified statistics with the new scores
            </summary>
            <param name="context">Context whose insight has just completed analysis</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.Step(System.DateTime)">
            <summary>
            Invokes the manager at the end of the time step.
            </summary>
            <param name="frontierTimeUtc">The current frontier time utc</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alphas.StatisticsInsightManagerExtension.InitializeForRange(System.DateTime,System.DateTime,System.DateTime)">
            <summary>
            Allows the extension to initialize itself over the expected range
            </summary>
            <param name="algorithmStartDate">The start date of the algorithm</param>
            <param name="algorithmEndDate">The end date of the algorithm</param>
            <param name="algorithmUtcTime">The algorithm's current utc time</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Alpha.IAlphaHandler">
            <summary>
            Alpha handler defines how to process insights generated by an algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alpha.IAlphaHandler.IsActive">
            <summary>
            Gets a flag indicating if this handler's thread is still running and processing messages
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Alpha.IAlphaHandler.RuntimeStatistics">
            <summary>
            Gets the current alpha runtime statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alpha.IAlphaHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
            <summary>
            Initializes this alpha handler to accept insights from the specified algorithm
            </summary>
            <param name="job">The algorithm job</param>
            <param name="algorithm">The algorithm instance</param>
            <param name="messagingHandler">Handler used for sending insights</param>
            <param name="api">Api instance</param>
            <param name="transactionHandler">Algorithms transaction handler</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alpha.IAlphaHandler.OnAfterAlgorithmInitialized(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Invoked after the algorithm's Initialize method was called allowing the alpha handler to check
            other things, such as sampling period for backtests
            </summary>
            <param name="algorithm">The algorithm instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alpha.IAlphaHandler.ProcessSynchronousEvents">
            <summary>
            Performs processing in sync with the algorithm's time loop to provide consisten reading of data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Alpha.IAlphaHandler.Exit">
            <summary>
            Stops processing in the <see cref="!:Run"/> method
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.AggregationManager">
            <summary>
            Aggregates ticks and bars based on given subscriptions. 
            Current implementation is based on <see cref="T:QuantConnect.Data.Consolidators.IDataConsolidator"/> that consolidates ticks and put them into enumerator.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Add(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Add new subscription to current <see cref="T:QuantConnect.Data.IDataAggregator"/> instance
            </summary>
            <param name="dataConfig">defines the parameters to subscribe to a data feed</param>
            <param name="newDataAvailableHandler">handler to be fired on new data available</param>
            <returns>The new enumerator for this subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Remove(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Removes the handler with the specified identifier
            </summary>
            <param name="dataConfig">Subscription data configuration to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Update(QuantConnect.Data.BaseData)">
            <summary>
            Add new data to aggregator
            </summary>
            <param name="input">The new data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.AggregationManager.Dispose">
            <summary>
            Dispose of the aggregation manager.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider">
            <summary>
            An instance of the <see cref="T:QuantConnect.Interfaces.IDataProvider"/> that will attempt to retrieve files not present on the filesystem from the API
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.Fetch(System.String)">
            <summary>
            Retrieves data to be used in an algorithm.
            If file does not exist, an attempt is made to download them from the api
            </summary>
            <param name="key">A string representing where the data is stored</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.IsOutOfDate(QuantConnect.Resolution,System.String)">
            <summary>
            Determine if the file is out of date based on configuration and needs to be updated
            </summary>
            <param name="resolution">Data resolution</param>
            <param name="filepath">Path to the file</param>
            <returns>True if the file is out of date</returns>
            <remarks>Files are only "out of date" for Hourly/Daily data because this data is stored all in one file</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ApiDataProvider.DownloadData(System.String,QuantConnect.Symbol,System.DateTime,QuantConnect.Resolution)">
            <summary>
            Attempt to download data using the Api for and return a FileStream of that data.
            </summary>
            <param name="key"></param>
            <param name="symbol"></param>
            <param name="date"></param>
            <param name="resolution"></param>
            <returns>A FileStream of the data</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BacktestingFutureChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IFutureChainProvider"/> that reads the list of contracts from open interest zip data files
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingFutureChainProvider.GetFutureContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of future contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the future chain (only used in backtesting)</param>
            <returns>The list of future contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BacktestingOptionChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IOptionChainProvider"/> that reads the list of contracts from open interest zip data files
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BacktestingOptionChainProvider.GetOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of option contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the option chain (only used in backtesting)</param>
            <returns>The list of option contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange">
            <summary>
            Provides a means of distributing output from enumerators from a dedicated separate thread
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SleepInterval">
            <summary>
            Gets or sets how long this thread will sleep when no data is available
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Name">
            <summary>
            Gets a name for this exchange
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange"/>
            </summary>
            <param name="name">A name for this exchange</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddEnumerator(QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler)">
            <summary>
            Adds the enumerator to this exchange. If it has already been added
            then it will remain registered in the exchange only once
            </summary>
            <param name="handler">The handler to use when this symbol's data is encountered</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddEnumerator(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{System.Boolean},System.Action{QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler})">
            <summary>
            Adds the enumerator to this exchange. If it has already been added
            then it will remain registered in the exchange only once
            </summary>
            <param name="symbol">A unique symbol used to identify this enumerator</param>
            <param name="enumerator">The enumerator to be added</param>
            <param name="shouldMoveNext">Function used to determine if move next should be called on this
            enumerator, defaults to always returning true</param>
            <param name="enumeratorFinished">Delegate called when the enumerator move next returns false</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetErrorHandler(System.Func{System.Exception,System.Boolean})">
            <summary>
            Sets the specified function as the error handler. This function
            returns true if it is a fatal error and queue consumption should
            cease.
            </summary>
            <param name="isFatalError">The error handling function to use when an
            error is encountered during queue consumption. Returns true if queue
            consumption should be stopped, returns false if queue consumption should
            continue</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetDataHandler(QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler)">
            <summary>
            Sets the specified hander function to handle data for the handler's symbol
            </summary>
            <param name="handler">The handler to use when this symbol's data is encountered</param>
            <returns>An identifier that can be used to remove this handler</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetDataHandler(QuantConnect.Symbol,System.Action{QuantConnect.Data.BaseData})">
            <summary>
            Sets the specified hander function to handle data for the handler's symbol
            </summary>
            <param name="symbol">The symbol whose data is to be handled</param>
            <param name="handler">The handler to use when this symbol's data is encountered</param>
            <returns>An identifier that can be used to remove this handler</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddDataHandler(QuantConnect.Symbol,System.Action{QuantConnect.Data.BaseData})">
            <summary>
            Adds the specified hander function to handle data for the handler's symbol
            </summary>
            <param name="symbol">The symbol whose data is to be handled</param>
            <param name="handler">The handler to use when this symbol's data is encountered</param>
            <returns>An identifier that can be used to remove this handler</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.RemoveDataHandler(QuantConnect.Symbol)">
            <summary>
            Removes the handler with the specified identifier
            </summary>
            <param name="symbol">The symbol to remove handlers for</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.RemoveEnumerator(QuantConnect.Symbol)">
            <summary>
            Removes and returns enumerator handler with the specified symbol.
            The removed handler is returned, null if not found
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Start(System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Begins consumption of the wrapped <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> on
            a separate thread
            </summary>
            <param name="token">A cancellation token used to signal to stop</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Stop">
            <summary>
            Ends consumption of the wrapped <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.ConsumeEnumerators(System.Threading.CancellationToken)">
            <summary> Entry point for queue consumption </summary>
            <param name="token">A cancellation token used to signal to stop</param>
            <remarks> This function only returns after <see cref="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Stop"/> is called or the token is cancelled</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler">
            <summary>
            Handler used to handle data emitted from enumerators
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.DataEmitted">
            <summary>
            Event fired when MoveNext returns true and Current is non-null
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.Symbol">
            <summary>
            The symbol this handler handles
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.#ctor(QuantConnect.Symbol)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler"/> class
            </summary>
            <param name="symbol">The symbol whose data is to be handled</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.OnDataEmitted(QuantConnect.Data.BaseData)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.DataEmitted"/> event
            </summary>
            <param name="data">The data being emitted</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler">
            <summary>
            Handler used to manage a single enumerator's move next/end of stream behavior
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.EnumeratorFinished">
            <summary>
            Event fired when MoveNext returns false
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.Symbol">
            <summary>
            A unique symbol used to identify this enumerator
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.Enumerator">
            <summary>
            The enumerator this handler handles
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.HandlesData">
            <summary>
            Determines whether or not this handler is to be used for handling the
            data emitted. This is useful when enumerators are not for a single symbol,
            such is the case with universe subscriptions
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{System.Boolean},System.Action{QuantConnect.Data.BaseData})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler"/> class
            </summary>
            <param name="symbol">The symbol to identify this enumerator</param>
            <param name="enumerator">The enumeator this handler handles</param>
            <param name="shouldMoveNext">Predicate function used to determine if we should call move next
            on the symbol's enumerator</param>
            <param name="handleData">Handler for data if HandlesData=true</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler"/> class
            </summary>
            <param name="symbol">The symbol to identify this enumerator</param>
            <param name="enumerator">The enumeator this handler handles</param>
            <param name="handlesData">True if this handler will handle the data, false otherwise</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.OnEnumeratorFinished">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.EnumeratorFinished"/> event
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.ShouldMoveNext">
            <summary>
            Returns true if this enumerator should move next
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.HandleData(QuantConnect.Data.BaseData)">
            <summary>
            Handles the specified data.
            </summary>
            <param name="data">The data to be handled</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader">
            <summary>
            A base class for implementations of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.IsLiveMode">
            <summary>
            True if we're in live mode, false for backtesting
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.DataCacheProvider">
            <summary>
            The data cache provider to use
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.Boolean)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.CreateStreamReader(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Interfaces.IStreamReader"/> for the specified <paramref name="subscriptionDataSource"/>
            </summary>
            <param name="subscriptionDataSource">The source to produce an <see cref="T:QuantConnect.Interfaces.IStreamReader"/> for</param>
            <returns>A new instance of <see cref="T:QuantConnect.Interfaces.IStreamReader"/> to read the source, or null if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.HandleLocalFileSource(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Opens up an IStreamReader for a local file source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseSubscriptionDataSourceReader.HandleRemoteSourceFile(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Opens up an IStreamReader for a remote file source
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IFutureChainProvider"/> that will cache by date future contracts returned by another future chain provider.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider.#ctor(QuantConnect.Interfaces.IFutureChainProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider"/> class
            </summary>
            <param name="futureChainProvider"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingFutureChainProvider.GetFutureContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of future contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the future chain (only used in backtesting)</param>
            <returns>The list of future contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IOptionChainProvider"/> that will cache by date option contracts returned by another option chain provider.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider.#ctor(QuantConnect.Interfaces.IOptionChainProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider"/> class
            </summary>
            <param name="optionChainProvider"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CachingOptionChainProvider.GetOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of option contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the option chain (only used in backtesting)</param>
            <returns>The list of option contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader">
            <summary>
            Collection Subscription Factory takes a BaseDataCollection from BaseData factories
            and yields it one point at a time to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader"/> class
            </summary>
            <param name="dataCacheProvider">Used to cache data for requested from the IDataProvider</param>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.ReaderError">
            <summary>
            Event fired when an exception is thrown during a call to
            <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.OnReaderError(System.String,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.ReaderError"/> event
            </summary>
            <param name="line">The line that caused the exception</param>
            <param name="exception">The exception that was caught</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
            <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> that was invalid</param>
            <param name="exception">The exception if one was raised, otherwise null</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs">
            <summary>
            Event arguments for the <see cref="!:TextSubscriptionDataSourceReader.CreateStreamReader"/> event
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.Date">
            <summary>
            Gets the date of the source
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.Source">
            <summary>
            Gets the source that caused the error
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.#ctor(System.DateTime,QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs"/> class
            </summary>
            <param name="date">The date of the source</param>
            <param name="source">The source that cause the error</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager">
            <summary>
            Helper class to keep track of required internal currency <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/>.
            This class is used by the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.#ctor(QuantConnect.Securities.CashBook,QuantConnect.Securities.SecurityManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Interfaces.ISecurityService,QuantConnect.Resolution)">
            <summary>
            Creates a new instance
            </summary>
            <param name="cashBook">The cash book instance</param>
            <param name="securityManager">The SecurityManager, required by the cash book for creating new securities</param>
            <param name="subscriptionManager">The SubscriptionManager, required by the cash book for creating new subscription data configs</param>
            <param name="securityService">The SecurityService, required by the cash book for creating new securities</param>
            <param name="defaultResolution">The default resolution to use for the internal subscriptions</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.GetSubscriptionDataConfigToRemove(QuantConnect.Symbol)">
            <summary>
            Will verify if there are any <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> to be removed
            for a given added <see cref="T:QuantConnect.Symbol"/>.
            </summary>
            <param name="addedSymbol">The symbol that was added to the data feed system</param>
            <returns>The SubscriptionDataConfig to be removed, null if none</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.UpdatePendingSubscriptionDataConfigs(QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Will update pending currency <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/>
            </summary>
            <returns>True when there are pending currency subscriptions <see cref="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.GetPendingSubscriptionDataConfigs"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.GetPendingSubscriptionDataConfigs">
            <summary>
            Will return any pending internal currency <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> and remove them as pending.
            </summary>
            <returns>Will return the <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> to be added</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CurrencySubscriptionDataConfigManager.EnsureCurrencySubscriptionDataConfigs(QuantConnect.Data.UniverseSelection.SecurityChanges,QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Checks the current <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> and adds new necessary currency pair feeds to provide real time conversion data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider">
            <summary>
            Specifies data channel settings
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider.ShouldStreamSubscription(QuantConnect.Packets.LiveNodePacket,QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            True if this subscription request should be streamed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataChannelProvider.IsStreamingType(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Returns true if the data type for the given subscription configuration supports streaming
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket">
            <summary>
            Defines a container type to hold data produced by a data feed subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Security">
            <summary>
            The security
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Configuration">
            <summary>
            The subscription configuration that produced this data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Count">
            <summary>
            Gets the number of data points held within this packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Data">
            <summary>
            The data for the security
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.IsSubscriptionRemoved">
            <summary>
            Gets whether or not this packet should be filtered out due to the subscription being removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.#ctor(QuantConnect.Interfaces.ISecurityPrice,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Util.IReadOnlyRef{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket"/> class
            </summary>
            <param name="security">The security whose data is held in this packet</param>
            <param name="configuration">The subscription configuration that produced this data</param>
            <param name="isSubscriptionRemoved">Reference to whether or not the subscription has since been removed, defaults to false</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.#ctor(QuantConnect.Interfaces.ISecurityPrice,QuantConnect.Data.SubscriptionDataConfig,System.Collections.Generic.List{QuantConnect.Data.BaseData},QuantConnect.Util.IReadOnlyRef{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket"/> class
            </summary>
            <param name="security">The security whose data is held in this packet</param>
            <param name="configuration">The subscription configuration that produced this data</param>
            <param name="data">The data to add to this packet. The list reference is reused
            internally and NOT copied.</param>
            <param name="isSubscriptionRemoved">Reference to whether or not the subscription has since been removed, defaults to false</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Add(QuantConnect.Data.BaseData)">
            <summary>
            Adds the specified data to this packet
            </summary>
            <param name="data">The data to be added to this packet</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataManager">
            <summary>
            DataManager will manage the subscriptions for both the DataFeeds and the SubscriptionManager
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.DataManager._subscriptionManagerSubscriptions">
            There is no ConcurrentHashSet collection in .NET,
            so we use ConcurrentDictionary with byte value to minimize memory usage
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionAdded">
            <summary>
            Event fired when a new subscription is added
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionRemoved">
            <summary>
            Event fired when an existing subscription is removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.#ctor(QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.DataFeeds.UniverseSelection,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.ITimeKeeper,QuantConnect.Securities.MarketHoursDatabase,System.Boolean,QuantConnect.Securities.IRegisteredSecurityDataTypesProvider,QuantConnect.Interfaces.IDataPermissionManager)">
            <summary>
            Creates a new instance of the DataManager
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.DataFeedSubscriptions">
            <summary>
            Gets the data feed subscription collection
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveAllSubscriptions">
            <summary>
            Will remove all current <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> to provide data for the specified security.
            </summary>
            <param name="request">Defines the <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> to be added</param>
            <returns>True if the subscription was created and added successfully, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Removes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>, if it exists
            </summary>
            <param name="configuration">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> of the subscription to remove</param>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>.
            Default value, null, will remove all universes</param>
            <returns>True if the subscription was successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.OnSubscriptionAdded(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionAdded"/> event
            </summary>
            <param name="subscription">The added subscription</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.OnSubscriptionRemoved(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionRemoved"/> event
            </summary>
            <param name="subscription">The removed subscription</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionManagerSubscriptions">
            <summary>
            Gets all the current data config subscriptions that are being processed for the SubscriptionManager
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionManagerGetOrAdd(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets existing or adds new <see cref="T:QuantConnect.Data.SubscriptionDataConfig" />
            </summary>
            <returns>Returns the SubscriptionDataConfig instance used</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.RemoveSubscriptionDataConfig(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Will try to remove a <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> and update the corresponding
            consumers accordingly
            </summary>
            <param name="subscription">The <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> owning the configuration to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.SubscriptionManagerCount">
            <summary>
            Returns the amount of data config subscriptions processed for the SubscriptionManager
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.AvailableDataTypes">
            <summary>
            The different <see cref="T:QuantConnect.TickType" /> each <see cref="T:QuantConnect.SecurityType" /> supports
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.Add(System.Type,QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,QuantConnect.DataNormalizationMode)">
            <summary>
            Creates and adds a list of <see cref="T:QuantConnect.Data.SubscriptionDataConfig" /> for a given symbol and configuration.
            Can optionally pass in desired subscription data type to use.
            If the config already existed will return existing instance instead
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.Add(QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.List{System.Tuple{System.Type,QuantConnect.TickType}},QuantConnect.DataNormalizationMode)">
            <summary>
            Creates and adds a list of <see cref="T:QuantConnect.Data.SubscriptionDataConfig" /> for a given symbol and configuration.
            Can optionally pass in desired subscription data types to use.
             If the config already existed will return existing instance instead
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.LookupSubscriptionConfigDataTypes(QuantConnect.SecurityType,QuantConnect.Resolution,System.Boolean)">
            <summary>
            Get the data feed types for a given <see cref="T:QuantConnect.SecurityType" /> <see cref="T:QuantConnect.Resolution" />
            </summary>
            <param name="symbolSecurityType">The <see cref="T:QuantConnect.SecurityType" /> used to determine the types</param>
            <param name="resolution">The resolution of the data requested</param>
            <param name="isCanonical">Indicates whether the security is Canonical (future and options)</param>
            <returns>Types that should be added to the <see cref="T:QuantConnect.Data.SubscriptionDataConfig" /></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataManager.GetSubscriptionDataConfigs(QuantConnect.Symbol,System.Boolean)">
            <summary>
            Gets a list of all registered <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> for a given <see cref="T:QuantConnect.Symbol"/>
            </summary>
            <remarks>Will not return internal subscriptions by default</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataManager.UniverseSelection">
            <summary>
            Get the universe selection instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager">
            <summary>
            Entity in charge of handling data permissions
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.DataChannelProvider">
            <summary>
            The data channel provider instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.Initialize(QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Initialize the data permission manager
            </summary>
            <param name="job">The job packet</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.AssertConfiguration(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Will assert the requested configuration is valid for the current job
            </summary>
            <param name="subscriptionDataConfig">The data subscription configuration to assert</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataPermissionManager.GetResolution(QuantConnect.Resolution)">
            <summary>
            Gets a valid resolution to use for internal subscriptions
            </summary>
            <returns>A permitted resolution for internal subscriptions</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider">
            <summary>
            Default file provider functionality that does not attempt to retrieve any data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.Fetch(System.String)">
            <summary>
            Retrieves data from disc to be used in an algorithm
            </summary>
            <param name="key">A string representing where the data is stored</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the data requested</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DefaultDataProvider.Dispose">
            <summary>
            The stream created by this type is passed up the stack to the IStreamReader
            The stream is closed when the StreamReader that wraps this stream is disposed</summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator">
            <summary>
            Auxiliary data enumerator that will, initialize and call the <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)"/>
            implementation each time there is a new tradable day for every <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider"/>
            provided.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.Lazy{QuantConnect.Data.Auxiliary.FactorFile},System.Lazy{QuantConnect.Data.Auxiliary.MapFile},QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider[],QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier,System.Boolean,System.DateTime)">
            <summary>
            Creates a new instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFile">The factor file to use</param>
            <param name="mapFile">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> to use</param>
            <param name="tradableDateEventProviders">The tradable dates event providers</param>
            <param name="tradableDayNotifier">Tradable dates provider</param>
            <param name="includeAuxiliaryData">True to emit auxiliary data</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Initialize(QuantConnect.Data.SubscriptionDataConfig,System.Lazy{QuantConnect.Data.Auxiliary.FactorFile},System.Lazy{QuantConnect.Data.Auxiliary.MapFile},QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider[],System.DateTime)">
            <summary>
            Late initialization so it is performed in the data feed stack
            and not in the algorithm thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element.
            </summary>
            <returns>Always true</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Dispose">
            <summary>
            Dispose of the Stream Reader and close out the source stream and file connections.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
            <remarks>Not used</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator.Current">
            <summary>
            Last read BaseData object from this type and source
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1">
            <summary>
            Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/>
            that aggregates an underlying <see cref="T:System.Collections.Generic.IEnumerator`1"/> into a single
            data packet
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator"/> class
            This will aggregate instances emitted from the underlying enumerator and tag them with the
            specified symbol
            </summary>
            <param name="enumerator">The underlying enumerator to aggregate</param>
            <param name="symbol">The symbol to place on the aggregated collection</param>
            <param name="liveMode">True if running in live mode</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.CreateCollection(QuantConnect.Symbol,System.DateTime,System.DateTime)">
            <summary>
            Creates a new, empty <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/>.
            </summary>
            <param name="symbol">The base data collection symbol</param>
            <param name="time">The start time of the collection</param>
            <param name="endTime">The end time of the collection</param>
            <returns>A new, empty <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Add(`0,QuantConnect.Data.BaseData)">
            <summary>
            Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData"/> to the current collection
            </summary>
            <param name="collection">The collection to be added to</param>
            <param name="current">The data to be added</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.SetData(`0,System.Collections.Generic.List{QuantConnect.Data.BaseData})">
            <summary>
            Adds all specified instances of <see cref="T:QuantConnect.Data.BaseData"/> to the current collection
            </summary>
            <param name="collection">The collection to be added to</param>
            <param name="current">The data collection to be added</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.IsValid(`0)">
            <summary>
            Determines if a given data point is valid and can be emitted
            </summary>
            <param name="collection">The collection to be emitted</param>
            <returns>True if its a valid data point</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator">
            <summary>
            Provides a non-generic implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator"/> class
            </summary>
            <param name="enumerator">The enumerator to aggregate</param>
            <param name="symbol">The output data's symbol</param>
            <param name="liveMode">True if running in live mode</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator">
            <summary>
            Enumerator that will concatenate enumerators together sequentially enumerating them in the provided order
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.Current">
            <summary>
            The current BaseData object
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.#ctor(System.Boolean,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Creates a new instance
            </summary>
            <param name="skipDuplicateEndTimes">True will skip data points from enumerators if before or at the last end time</param>
            <param name="enumerators">The sequence of enumerators to concatenate</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>True if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ConcatEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator">
            <summary>
            Enumerates live futures symbol universe data into <see cref="T:QuantConnect.Data.UniverseSelection.FuturesChainUniverseDataCollection"/> instances
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.#ctor(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator"/> class.
            </summary>
            <param name="subscriptionRequest">The subscription request to be used</param>
            <param name="universeProvider">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider to be used</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Current">
            <summary>
            Returns current futures chain enumerator position
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns current futures chain enumerator position
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator">
            <summary>
            Enumerates live options symbol universe data into <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection"/> instances
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Underlying">
            <summary>
            Gets the enumerator for the underlying asset
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.#ctor(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator"/> class.
            </summary>
            <param name="subscriptionRequest">The subscription request to be used</param>
            <param name="underlying">Underlying enumerator</param>
            <param name="universeProvider">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider to be used</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Current">
            <summary>
            Returns current option chain enumerator position
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns current option chain enumerator position
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.Delisting"/> events
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.Auxiliary.FactorFile,QuantConnect.Data.Auxiliary.MapFile,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFile">The factor file to use</param>
            <param name="mapFile">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for delistings
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New delisting event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.Dividend"/> events
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.Auxiliary.FactorFile,QuantConnect.Data.Auxiliary.MapFile,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFile">The factor file to use</param>
            <param name="mapFile">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for dividends and returns them
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New Dividend event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that relies on the
            <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Enqueue(`0)"/> method being called and only ends when <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Stop"/>
            is called
            </summary>
            <typeparam name="T">The item type yielded by the enumerator</typeparam>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Count">
            <summary>
            Gets the current number of items held in the internal queue
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.LastEnqueued">
            <summary>
            Gets the last item that was enqueued
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.HasFinished">
            <summary>
            Returns true if the enumerator has finished and will not accept any more data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1"/> class
            </summary>
            <param name="blocking">Specifies whether or not to use the blocking behavior</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Enqueue(`0)">
            <summary>
            Enqueues the new data into this enumerator
            </summary>
            <param name="data">The data to be enqueued</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Stop">
            <summary>
            Signals the enumerator to stop enumerating when the items currently
            held inside are gone. No more items will be added to this enumerator.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that reads
            an entire <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> into a single <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/>
            to be emitted on the tradable date at midnight
            </summary>
            <remarks>This enumerator factory is currently only used in backtesting with coarse data</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory">
            <summary>
            Provides a default implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that uses
            <see cref="T:QuantConnect.Data.BaseData"/> factory methods for reading sources
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.#ctor(System.Boolean,QuantConnect.Data.Auxiliary.MapFileResolver,QuantConnect.Interfaces.IFactorFileProvider,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="isLiveMode">True for live mode, false otherwise</param>
            <param name="mapFileResolver">Used for resolving the correct map files</param>
            <param name="factorFileProvider">Used for getting factor files</param>
            <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
            Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.#ctor(System.Boolean,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="isLiveMode">True for live mode, false otherwise</param>
            <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
            Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.CorporateEventEnumeratorFactory">
            <summary>
            Helper class used to create the corporate event providers
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider"/>, <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider"/>,
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DividendEventProvider"/>, <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DelistingEventProvider"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.CorporateEventEnumeratorFactory.CreateEnumerators(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier,QuantConnect.Data.Auxiliary.MapFileResolver,System.Boolean,System.DateTime,System.Boolean)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.AuxiliaryDataEnumerator"/> that will hold the
            corporate event providers
            </summary>
            <param name="rawDataEnumerator">The underlying raw data enumerator</param>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFileProvider">Used for getting factor files</param>
            <param name="tradableDayNotifier">Tradable dates provider</param>
            <param name="mapFileResolver">Used for resolving the correct map files</param>
            <param name="includeAuxiliaryData">True to emit auxiliary data</param>
            <param name="startTime">Start date for the data request</param>
            <param name="enablePriceScaling">Applies price factor</param>
            <returns>The new auxiliary data enumerator</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.CorporateEventEnumeratorFactory.ShouldEmitAuxiliaryBaseData(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Centralized logic used by the data feeds to determine if we should emit auxiliary base data points.
            For equities we only want to emit split/dividends events for non internal and only for <see cref="T:QuantConnect.Data.Market.TradeBar"/> configurations
            this last part is because equities also have <see cref="T:QuantConnect.Data.Market.QuoteBar"/> subscriptions.
            </summary>
            <remarks>The <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory"/> does not allow for multiple dividends/splits per symbol in the same time slice
            but we don't want to rely only on that and make an explicit decision here.</remarks>
            <remarks>History provider is never emitting auxiliary data points</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that reads
            an entire <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> into a single <see cref="F:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.FineFundamental"/>
            to be emitted on the tradable date at midnight
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.#ctor(System.Boolean,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory"/> class.
            </summary>
            <param name="isLiveMode">True for live mode, false otherwise</param>
            <param name="tradableDaysProvider">Function used to provide the tradable dates to the enumerator.
            Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.GetSource(QuantConnect.Data.Fundamental.FineFundamental,QuantConnect.Data.SubscriptionDataConfig,System.DateTime)">
            <summary>
            Returns a SubscriptionDataSource for the FineFundamental class,
            returning data from a previous date if not available for the requested date
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> for the <see cref="T:QuantConnect.Data.UniverseSelection.FuturesChainUniverse"/> in backtesting
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="enumeratorConfigurator">Function used to configure the sub-enumerators before sync (fill-forward/filter/ect...)</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory.#ctor(QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="symbolUniverse">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider to be used</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> to handle live custom data.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory.#ctor(QuantConnect.ITimeProvider,System.Func{System.DateTime,System.DateTime})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="timeProvider">Time provider from data feed</param>
            <param name="dateAdjustment">Func that allows adjusting the datetime to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request.
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.LiveCustomDataSubscriptionEnumeratorFactory.GetSubscriptionDataSourceReader(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,QuantConnect.Data.BaseData)">
            <summary>
            Gets the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> for the specified source
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> for the <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverse"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="enumeratorConfigurator">Function used to configure the sub-enumerators before sync (fill-forward/filter/ect...)</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}},QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="enumeratorConfigurator">Function used to configure the sub-enumerators before sync (fill-forward/filter/ect...)</param>
            <param name="symbolUniverse">Symbol universe provider of the data queue</param>
            <param name="timeProvider">The time provider instance used to determine when bars are completed and can be emitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> that used the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader"/>
            </summary>
            <remarks>Only used on backtesting by the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.#ctor(QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,System.Boolean,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="resultHandler">The result handler for the algorithm</param>
            <param name="mapFileProvider">The map file provider</param>
            <param name="factorFileProvider">The factor file provider</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <param name="includeAuxiliaryData">True to check for auxiliary data, false otherwise</param>
            <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
            Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays"/></param>
            <param name="enablePriceScaling">Applies price factor</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader"/> to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory"/> to emit
            ticks based on <see cref="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.GetTriggerTimes(System.DateTime,System.DateTime,QuantConnect.Securities.MarketHoursDatabase)"/>, allowing universe
            selection to fire at planned times.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory.#ctor(QuantConnect.Data.UniverseSelection.ITimeTriggeredUniverse,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory"/> class
            </summary>
            <param name="universe">The user defined universe</param>
            <param name="marketHoursDatabase">The market hours database</param>
            <param name="timeProvider">The time provider</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.TimeTriggeredUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataProvider)">
            <summary>
            Creates an enumerator to read the specified request
            </summary>
            <param name="request">The subscription request to be read</param>
            <param name="dataProvider">Provider used to get data when it is not present on disk</param>
            <returns>An enumerator reading the subscription request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator">
            <summary>
            Provides the ability to fast forward an enumerator based on the age of the data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.ITimeProvider,NodaTime.DateTimeZone,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator"/> class
            </summary>
            <param name="enumerator">The source enumerator</param>
            <param name="timeProvider">A time provider used to determine age of data</param>
            <param name="timeZone">The data's time zone</param>
            <param name="maximumDataAge">The maximum age of data allowed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator">
            <summary>
            The FillForwardEnumerator wraps an existing base data enumerator and inserts extra 'base data' instances
            on a specified fill forward resolution
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Exchange">
            <summary>
            The exchange used to determine when to insert fill forward data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchange,QuantConnect.Util.IReadOnlyRef{System.TimeSpan},System.Boolean,System.DateTime,System.TimeSpan,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/> class that accepts
            a reference to the fill forward resolution, useful if the fill forward resolution is dynamic
            and changing as the enumeration progresses
            </summary>
            <param name="enumerator">The source enumerator to be filled forward</param>
            <param name="exchange">The exchange used to determine when to insert fill forward data</param>
            <param name="fillForwardResolution">The resolution we'd like to receive data on</param>
            <param name="isExtendedMarketHours">True to use the exchange's extended market hours, false to use the regular market hours</param>
            <param name="subscriptionEndTime">The end time of the subscrition, once passing this date the enumerator will stop</param>
            <param name="dataResolution">The source enumerator's data resolution</param>
            <param name="dataTimeZone">The time zone of the underlying source data. This is used for rounding calculations and
            is NOT the time zone on the BaseData instances (unless of course data time zone equals the exchange time zone)</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.RequiresFillForwardData(System.TimeSpan,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData@)">
            <summary>
            Determines whether or not fill forward is required, and if true, will produce the new fill forward data
            </summary>
            <param name="fillForwardResolution"></param>
            <param name="previous">The last piece of data emitted by this enumerator</param>
            <param name="next">The next piece of data on the source enumerator</param>
            <param name="fillForward">When this function returns true, this will have a non-null value, null when the function returns false</param>
            <returns>True when a new fill forward piece of data was produced and should be emitted by this enumerator</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.GetReferenceDateIntervals(System.DateTime,System.TimeSpan)">
            <summary>
            Get potential next fill forward bars.
            </summary>
            <remarks>Special case where fill forward resolution and data resolution are equal</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.GetReferenceDateIntervals(System.DateTime,System.TimeSpan,System.TimeSpan)">
            <summary>
            Get potential next fill forward bars.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.RoundDown(System.DateTime,System.TimeSpan)">
            <summary>
            We need to round down in data timezone.
            For example GH issue 4392: Forex daily data, exchange tz time is 8PM, but time in data tz is 12AM
            so rounding down on exchange tz will crop it, while rounding on data tz will return the same data point time.
            Why are we even doing this? being able to determine the next valid data point for a resolution from a data point that might be in another resolution
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator">
            <summary>
            Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that will not emit
            data ahead of the frontier as specified by an instance of <see cref="T:QuantConnect.ITimeProvider"/>.
            An instance of <see cref="T:QuantConnect.TimeZoneOffsetProvider"/> is used to convert between UTC
            and the data's native time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.ITimeProvider,QuantConnect.TimeZoneOffsetProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator"/> class
            </summary>
            <param name="enumerator">The underlying enumerator to make frontier aware</param>
            <param name="timeProvider">The time provider used for resolving the current frontier time</param>
            <param name="offsetProvider">An offset provider used for converting the frontier UTC time into the data's native time zone</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator">
            <summary>
            Aggregates an enumerator into <see cref="T:QuantConnect.Data.UniverseSelection.FuturesChainUniverseDataCollection"/> instances
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator"/> class
            </summary>
            <param name="enumerator">The enumerator to aggregate</param>
            <param name="symbol">The output data's symbol</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator.Add(QuantConnect.Data.UniverseSelection.FuturesChainUniverseDataCollection,QuantConnect.Data.BaseData)">
            <summary>
            Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData"/> to the current collection
            </summary>
            <param name="collection">The collection to be added to</param>
            <param name="current">The data to be added</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider">
            <summary>
            Interface for event providers for new tradable dates
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Called each time there is a new tradable day
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New corporate event if any</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDateEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.Auxiliary.FactorFile,QuantConnect.Data.Auxiliary.MapFile,System.DateTime)">
            <summary>
            Initializes the event provider instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFile">The factor file to use</param>
            <param name="mapFile">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier">
            <summary>
            Interface which will provide an event handler
            who will be fired with each new tradable day
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ITradableDatesNotifier.NewTradableDate">
            <summary>
            Event fired when there is a new tradable date
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator">
            <summary>
            Emits auxiliary data points ready to be time synced
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.#ctor(NodaTime.DateTimeZone,QuantConnect.ITimeProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator"/> class
            </summary>
            <param name="timeZone">The time zone the raw data is time stamped in</param>
            <param name="timeProvider">The time provider instance used to determine when bars are completed and
            can be emitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.Enqueue(QuantConnect.Data.BaseData)">
            <summary>
            Pushes the data point. This data point will be emitted after the allotted time has passed
            </summary>
            <param name="data">The new data point</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveAuxiliaryDataEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator">
            <summary>
            Represents an enumerator capable of synchronizing live equity data enumerators in time.
            This assumes that all enumerators have data time stamped in the same time zone.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator.#ctor(QuantConnect.ITimeProvider,NodaTime.DateTimeZone,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator"/> class
            </summary>
            <param name="timeProvider">The source of time used to gauge when this enumerator should emit extra bars when null data is returned from the source enumerator</param>
            <param name="exchangeTimeZone">The time zone the raw data is time stamped in</param>
            <param name="tradeBarAggregator">The trade bar aggregator enumerator</param>
            <param name="auxDataEnumerators">The auxiliary data enumerators</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns> true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>The element in the collection at the current position of the enumerator.</returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>The current element in the collection.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveEquityDataSynchronizingEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator">
            <summary>
            An implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/> that uses an <see cref="T:QuantConnect.ITimeProvider"/>
            to determine if a fill forward bar needs to be emitted
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.#ctor(QuantConnect.ITimeProvider,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchange,QuantConnect.Util.IReadOnlyRef{System.TimeSpan},System.Boolean,System.DateTime,System.TimeSpan,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator"/> class that accepts
            a reference to the fill forward resolution, useful if the fill forward resolution is dynamic
            and changing as the enumeration progresses
            </summary>
            <param name="timeProvider">The source of time used to gauage when this enumerator should emit extra bars when
            null data is returned from the source enumerator</param>
            <param name="enumerator">The source enumerator to be filled forward</param>
            <param name="exchange">The exchange used to determine when to insert fill forward data</param>
            <param name="fillForwardResolution">The resolution we'd like to receive data on</param>
            <param name="isExtendedMarketHours">True to use the exchange's extended market hours, false to use the regular market hours</param>
            <param name="subscriptionEndTime">The end time of the subscription, once passing this date the enumerator will stop</param>
            <param name="dataResolution">The source enumerator's data resolution</param>
            <param name="dataTimeZone">Time zone of the underlying source data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.RequiresFillForwardData(System.TimeSpan,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData@)">
            <summary>
            Determines whether or not fill forward is required, and if true, will produce the new fill forward data
            </summary>
            <param name="fillForwardResolution"></param>
            <param name="previous">The last piece of data emitted by this enumerator</param>
            <param name="next">The next piece of data on the source enumerator, this may be null</param>
            <param name="fillForward">When this function returns true, this will have a non-null value, null when the function returns false</param>
            <returns>True when a new fill forward piece of data was produced and should be emitted by this enumerator</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> events
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.Auxiliary.FactorFile,QuantConnect.Data.Auxiliary.MapFile,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFile">The factor file to use</param>
            <param name="mapFile">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.MappingEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for new mappings
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New mapping event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator">
            <summary>
            Enumerates data into <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection"/> instances
            </summary>
            <remarks>Used in backtest mode <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator"/> class
            </summary>
            <param name="enumerator">The enumerator to aggregate</param>
            <param name="symbol">The output data's symbol</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator.Add(QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection,QuantConnect.Data.BaseData)">
            <summary>
            Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData"/> to the current collection
            </summary>
            <param name="collection">The collection to be added to</param>
            <param name="current">The data to be added</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator.IsValid(QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection)">
            <summary>
            Determines if a given data point is valid and can be emitted
            </summary>
            <param name="collection">The collection to be emitted</param>
            <returns>True if its a valid data point</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator">
            <summary>
            This enumerator will update the <see cref="F:QuantConnect.Data.SubscriptionDataConfig.PriceScaleFactor"/> when required
            and adjust the raw <see cref="T:QuantConnect.Data.BaseData"/> prices based on the provided <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/>.
            Assumes the prices of the provided <see cref="T:System.Collections.IEnumerator"/> are in raw mode.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Explicit interface implementation for <see cref="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Current"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Current">
            <summary>
            Last read <see cref="T:QuantConnect.Data.BaseData"/> object from this type and source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Data.SubscriptionDataConfig,System.Lazy{QuantConnect.Data.Auxiliary.FactorFile})">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator"/>.
            </summary>
            <param name="rawDataEnumerator">The underlying raw data enumerator</param>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> to enumerate for.
            Will determine the <see cref="T:QuantConnect.DataNormalizationMode"/> to use.</param>
            <param name="factorFile">The <see cref="T:QuantConnect.Data.Auxiliary.FactorFile"/> instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Dispose">
            <summary>
            Dispose of the underlying enumerator.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            True if the enumerator was successfully advanced to the next element;
            False if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.PriceScaleFactorEnumerator.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
            <remarks>Not used</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator">
            <summary>
            The QuoteBarFillForwardEnumerator wraps an existing base data enumerator
            If the current QuoteBar has null Bid and/or Ask bars, it copies them from the previous QuoteBar
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator"/> class
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarFillForwardEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1">
            <summary>
            Provides augmentation of how often an enumerator can be called. Time is measured using
            an <see cref="T:QuantConnect.ITimeProvider"/> instance and calls to the underlying enumerator are limited
            to a minimum time between each call.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},QuantConnect.ITimeProvider,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1"/> class
            </summary>
            <param name="enumerator">The underlying enumerator to place rate limits on</param>
            <param name="timeProvider">Time provider used for determing the time between calls</param>
            <param name="minimumTimeBetweenCalls">The minimum time allowed between calls to the underlying enumerator</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1">
            <summary>
            Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that will
            always return true via MoveNext.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1"/> class
            </summary>
            <param name="enumeratorFactory">Enumerator factory used to regenerate the underlying
            enumerator when it ends</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.IEnumerator`1"/> that relies on "consolidated" data
            </summary>
            <typeparam name="T">The item type yielded by the enumerator</typeparam>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.#ctor(QuantConnect.Data.Consolidators.IDataConsolidator,NodaTime.DateTimeZone,QuantConnect.ITimeProvider,System.EventHandler,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1"/> class
            </summary>
            <param name="consolidator">Consolidator taking BaseData updates and firing events containing new 'consolidated' data</param>
            <param name="timeZone">The time zone the raw data is time stamped in</param>
            <param name="timeProvider">The time provider instance used to determine when bars are completed and can be emitted</param>
            <param name="newDataAvailableHandler">The event handler for a new available data point</param>
            <param name="isPeriodBased">The consolidator is period based, this will enable scanning on <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.MoveNext"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Update(`0)">
            <summary>
            Updates the consolidator
            </summary>
            <param name="data">The data to consolidate</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Enqueue(`0)">
            <summary>
            Enqueues the new data into this enumerator
            </summary>
            <param name="data">The data to be enqueued</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.ScannableEnumerator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider">
            <summary>
            Event provider who will emit <see cref="T:QuantConnect.Data.Market.Split"/> events
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.Initialize(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.Auxiliary.FactorFile,QuantConnect.Data.Auxiliary.MapFile,System.DateTime)">
            <summary>
            Initializes this instance
            </summary>
            <param name="config">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></param>
            <param name="factorFile">The factor file to use</param>
            <param name="mapFile">The <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> to use</param>
            <param name="startTime">Start date for the data request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SplitEventProvider.GetEvents(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Check for new splits
            </summary>
            <param name="eventArgs">The new tradable day event arguments</param>
            <returns>New split event if any</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> which wraps an existing <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>Using this class is important, versus directly yielding, because we setup the <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Dispose"/> chain</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SecurityExchangeHours,QuantConnect.TimeZoneOffsetProvider,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
            <summary>
            Creates a new instance
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="exchangeHours">The security's exchange hours</param>
            <param name="offsetProvider">The subscription's time zone offset provider</param>
            <param name="enumerator">The underlying data enumerator</param>
            <returns>A subscription data enumerator</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>True if the enumerator was successfully advanced to the next element;
            False if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionDataEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator">
            <summary>
            Implements a wrapper around a base data enumerator to provide a final filtering step
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError">
            <summary>
            Fired when there's an error executing a user's data filter
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.WrapForDataFeed(QuantConnect.Lean.Engine.Results.IResultHandler,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.Security,System.DateTime,System.Boolean,System.Boolean)">
            <summary>
            Convenience method to wrap the enumerator and attach the data filter event to log and alery users of errors
            </summary>
            <param name="resultHandler">Result handler reference used to send errors</param>
            <param name="enumerator">The source enumerator to be wrapped</param>
            <param name="security">The security who's data is being enumerated</param>
            <param name="endTime">The end time of the subscription</param>
            <param name="extendedMarketHours">True if extended market hours are enabled</param>
            <param name="liveMode">True if live mode</param>
            <returns>A new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator"/> class that has had it's <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError"/>
            event subscribed to to send errors to the result handler</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.Security,System.DateTime,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator"/> class
            </summary>
            <param name="enumerator">The source enumerator to be wrapped</param>
            <param name="security">The security containing an exchange and data filter</param>
            <param name="endTime">The end time of the subscription</param>
            <param name="extendedMarketHours">True if extended market hours are enabled</param>
            <param name="liveMode">True if live mode</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.OnDataFilterError(System.Exception)">
            <summary>
            Event invocated for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError"/> event
            </summary>
            <param name="exception">The exception that was thrown when trying to perform data filtering</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator">
            <summary>
            Represents an enumerator capable of synchronizing other base data enumerators in time.
            This assumes that all enumerators have data time stamped in the same time zone
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator"/> class
            </summary>
            <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.GetSynchronizedEnumerator(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Synchronization system for the enumerator:
            </summary>
            <param name="enumerators"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.GetBinarySearchMethod(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Binary search for the enumerator stack synchronization
            </summary>
            <param name="enumerators"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.ListInsert(QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.SynchronizedEnumerator[],System.Int32,QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.SynchronizedEnumerator,System.Int32)">
            <summary>
            Shuffle the enumerator position in the list.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.GetBruteForceMethod(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
            <summary>
            Brute force implementation for synchronizing the enumerator.
            Will remove enumerators returning false to the call to MoveNext.
            Will not remove enumerators with Current Null returning true to the call to MoveNext
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed">
            <summary>
            Historical datafeed stream reader for processing files on a local disk.
            </summary>
            <remarks>Filesystem datafeeds are incredibly fast</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.IsActive">
            <summary>
            Flag indicating the hander thread is completely finished and ready to dispose.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <summary>
            Initializes the data feed for the specified job and algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription to provide data for the specified security.
            </summary>
            <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
            <returns>The created <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> if successful, null otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Removes the subscription from the data feed, if it exists
            </summary>
            <param name="subscription">The subscription to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.CreateUniverseSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a new subscription for universe selection
            </summary>
            <param name="request">The subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Exit">
            <summary>
            Send an exit signal to the thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.ConfigureEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Boolean,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
            <summary>
            Configure the enumerator with aggregation/fill-forward/filter behaviors. Returns new instance if re-configured
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed">
            <summary>
            Datafeed interface for creating custom datafeed sources.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.IsActive">
            <summary>
            Public flag indicator that the thread is still busy.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <summary>
            Initializes the data feed for the specified job and algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription to provide data for the specified security.
            </summary>
            <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
            <returns>The created <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> if successful, null otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Removes the subscription from the data feed, if it exists
            </summary>
            <param name="subscription">The subscription to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Exit">
            <summary>
            External controller calls to signal a terminate of the thread.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager">
            <summary>
            DataFeedSubscriptionManager interface will manage the subscriptions for the Data Feed
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.SubscriptionAdded">
            <summary>
            Event fired when a new subscription is added
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.SubscriptionRemoved">
            <summary>
            Event fired when an existing subscription is removed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.DataFeedSubscriptions">
            <summary>
            Gets the data feed subscription collection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.UniverseSelection">
            <summary>
            Get the universe selection instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Removes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>, if it exists
            </summary>
            <param name="configuration">The <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/> of the subscription to remove</param>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>.
            Default value, null, will remove all universes</param>
            <returns>True if the subscription was successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> to provide data for the specified security.
            </summary>
            <param name="request">Defines the <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> to be added</param>
            <returns>True if the subscription was created and added successfully, false otherwise</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider">
            <summary>
            Reduced interface which exposes required <see cref="T:QuantConnect.ITimeProvider"/> for <see cref="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed"/> implementations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider.FrontierTimeProvider">
            <summary>
            Time provider which returns current UTC frontier time
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataManager">
            <summary>
            IDataManager is the engines view of the Data Manager.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataManager.UniverseSelection">
            <summary>
            Get the universe selection instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader">
            <summary>
            This <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> implementation supports
            the <see cref="F:QuantConnect.Data.FileFormat.Index"/> and <see cref="T:QuantConnect.Data.IndexedBaseData"/> types.
            Handles the layer of indirection for the index data source and forwards
            the target source to the corresponding <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/>
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Creates a new instance of this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.IndexSubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
            <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> that was invalid</param>
            <param name="exception">The exception if one was raised, otherwise null</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager">
            <summary>
            Class in charge of handling Leans internal subscriptions
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.Added">
            <summary>
            Event fired when a new internal subscription request is to be added
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.Removed">
            <summary>
            Event fired when an existing internal subscription should be removed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.#ctor(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Resolution)">
            <summary>
            Creates a new instances
            </summary>
            <param name="algorithm">The associated algorithm</param>
            <param name="resolution">The resolution to use for the internal subscriptions</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.AddedSubscriptionRequest(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Notifies about a removed subscription request
            </summary>
            <param name="request">The removed subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.RemovedSubscriptionRequest(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Notifies about an added subscription request
            </summary>
            <param name="request">The added subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InternalSubscriptionManager.PreFilter(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            True for for live trading, non internal, non universe subscriptions, non custom data subscriptions
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs">
            <summary>
            Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.Source">
            <summary>
            Gets the source that was considered invalid
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.Exception">
            <summary>
            Gets the exception that was encountered
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.#ctor(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs"/> class
            </summary>
            <param name="source">The source that was considered invalid</param>
            <param name="exception">The exception that was encountered</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader">
            <summary>
            Represents a type responsible for accepting an input <see cref="T:QuantConnect.Data.SubscriptionDataSource"/>
            and returning an enumerable of the source's <see cref="T:QuantConnect.Data.BaseData"/>
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionSynchronizer">
            <summary>
            Provides the ability to synchronize subscriptions into time slices
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionSynchronizer.SubscriptionFinished">
            <summary>
            Event fired when a subscription is finished
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionSynchronizer.Sync(System.Collections.Generic.IEnumerable{QuantConnect.Lean.Engine.DataFeeds.Subscription},System.Threading.CancellationToken)">
            <summary>
            Syncs the specified subscriptions. The frontier time used for synchronization is
            managed internally and dependent upon previous synchronization operations.
            </summary>
            <param name="subscriptions">The subscriptions to sync</param>
            <param name="cancellationToken">The cancellation token to stop enumeration</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer">
            <summary>
            Interface which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer.StreamData(System.Threading.CancellationToken)">
            <summary>
            Returns an enumerable which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveFutureChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IFutureChainProvider"/> that fetches the list of contracts
            from an external source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveFutureChainProvider.GetFutureContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of future contracts for a given underlying symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the future chain (only used in backtesting)</param>
            <returns>The list of future contracts</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider">
            <summary>
            An implementation of <see cref="T:QuantConnect.Interfaces.IOptionChainProvider"/> that fetches the list of contracts
            from the Options Clearing Corporation (OCC) website
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.#cctor">
            <summary>
            Static constructor for the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.GetOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the option chain associated with the underlying Symbol
            </summary>
            <param name="underlyingSymbol">Underlying symbol to get the option chain for</param>
            <param name="date">Unused</param>
            <returns>Option chain</returns>
            <exception cref="T:System.ArgumentException">Option underlying Symbol is not Future or Equity</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.GetEquityOptionContractList(QuantConnect.Symbol,System.DateTime)">
            <summary>
            Gets the list of option contracts for a given underlying equity symbol
            </summary>
            <param name="symbol">The underlying symbol</param>
            <param name="date">The date for which to request the option chain (only used in backtesting)</param>
            <returns>The list of option contracts</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveOptionChainProvider.FindEquityOptionContracts(System.String)">
            <summary>
            Retrieve the list of option contracts for an underlying symbol from the OCC website
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer">
            <summary>
            Implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer"/> interface which provides the mechanism to stream live data to the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Initializes the instance of the Synchronizer class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.StreamData(System.Threading.CancellationToken)">
            <summary>
            Returns an enumerable which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.Dispose">
            <summary>
            Free resources
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.GetTimeProvider">
            <summary>
            Gets the <see cref="T:QuantConnect.ITimeProvider"/> to use. By default this will load the
            <see cref="T:QuantConnect.RealTimeProvider"/> for live mode, else <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider"/>
            </summary>
            <returns>The <see cref="T:QuantConnect.ITimeProvider"/> to use</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer.GetPulseDueTime(System.DateTime)">
            <summary>
            Will return the amount of milliseconds that are missing for the next time pulse
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed"/> that is designed to deal with
            live, remote data sources
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.IsActive">
            <summary>
            Public flag indicator that the thread is still busy.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <summary>
            Initializes the data feed for the specified job and algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription to provide data for the specified security.
            </summary>
            <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
            <returns>The created <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> if successful, null otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Removes the subscription from the data feed, if it exists
            </summary>
            <param name="subscription">The subscription to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Exit">
            <summary>
            External controller calls to signal a terminate of the thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetDataQueueHandler">
            <summary>
            Gets the <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> to use. By default this will try to load
            the type specified in the configuration via the 'data-queue-handler'
            </summary>
            <returns>The loaded <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateDataSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription for the specified security
            </summary>
            <param name="request">The subscription request</param>
            <returns>A new subscription instance of the specified security</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateUniverseSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Creates a new subscription for universe selection
            </summary>
            <param name="request">The subscription request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetConfiguredFrontierAwareEnumerator(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.TimeZoneOffsetProvider,System.Func{System.DateTime,System.Boolean})">
            <summary>
            Will wrap the provided enumerator with a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator"/>
            using a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider"/> that will advance time based on the provided
            function
            </summary>
            <remarks>Won't advance time if now.Hour is bigger or equal than 23pm, less or equal than 5am or Saturday.
            This is done to prevent universe selection occurring in those hours so that the subscription changes
            are handled correctly.</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler">
            <summary>
            Overrides methods of the base data exchange implementation
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler.ShouldMoveNext">
            <summary>
            Returns true if this enumerator should move next
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler.OnEnumeratorFinished">
            <summary>
            Calls stop on the internal enqueueable enumerator
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler.HandleData(QuantConnect.Data.BaseData)">
            <summary>
            Enqueues the data
            </summary>
            <param name="data">The data to be handled</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.ITimeProvider"/> that can be
            manually advanced through time
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.#ctor(NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider"/>
            </summary>
            <param name="setCurrentTimeTimeZone">Specify to use this time zone when calling <see cref="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)"/>,
            leave null for the default of <see cref="F:QuantConnect.TimeZones.Utc"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.#ctor(System.DateTime,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider"/> class
            </summary>
            <param name="currentTime">The current time in the specified time zone, if the time zone is
            null then the time is interpreted as being in <see cref="F:QuantConnect.TimeZones.Utc"/></param>
            <param name="setCurrentTimeTimeZone">Specify to use this time zone when calling <see cref="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)"/>,
            leave null for the default of <see cref="F:QuantConnect.TimeZones.Utc"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.GetUtcNow">
            <summary>
            Gets the current time in UTC
            </summary>
            <returns>The current time in UTC</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTimeUtc(System.DateTime)">
            <summary>
            Sets the current time interpreting the specified time as a UTC time
            </summary>
            <param name="time">The current time in UTC</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)">
            <summary>
            Sets the current time interpeting the specified time as a local time
            using the time zone used at instatiation.
            </summary>
            <param name="time">The local time to set the current time time, will be
            converted into UTC</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.Advance(System.TimeSpan)">
            <summary>
            Advances the current time by the specified span
            </summary>
            <param name="span">The amount of time to advance the current time by</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.AdvanceSeconds(System.Double)">
            <summary>
            Advances the current time by the specified number of seconds
            </summary>
            <param name="seconds">The number of seconds to advance the current time by</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed">
            <summary>
            Null data feed implementation. <seealso cref="T:QuantConnect.Lean.Engine.DataFeeds.DataManager"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.IsActive">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager,QuantConnect.Lean.Engine.DataFeeds.IDataFeedTimeProvider,QuantConnect.Interfaces.IDataChannelProvider)">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.RemoveSubscription(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.NullDataFeed.Exit">
            <inheritdoc />
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager">
            <summary>
            Helper class used to managed pending security removals <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.PendingRemovals">
            <summary>
            Current pending removals
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.#ctor(QuantConnect.Securities.IOrderProvider)">
            <summary>
            Create a new instance
            </summary>
            <param name="orderProvider">The order provider used to determine if it is safe to remove a security</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.IsSafeToRemove(QuantConnect.Securities.Security,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Determines if we can safely remove the security member from a universe.
            We must ensure that we have zero holdings, no open orders, and no existing portfolio targets
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.TryRemoveMember(QuantConnect.Securities.Security,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Will determine if the <see cref="T:QuantConnect.Securities.Security"/> can be removed.
            If it can be removed will add it to <see cref="P:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.PendingRemovals"/>
            </summary>
            <param name="member">The security to remove</param>
            <param name="universe">The universe which the security is a member of</param>
            <returns>The member to remove</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.CheckPendingRemovals(System.Collections.Generic.HashSet{QuantConnect.Symbol},QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Will check pending security removals
            </summary>
            <param name="selectedSymbols">Currently selected symbols</param>
            <param name="currentUniverse">Current universe</param>
            <returns>The members to be removed</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PendingRemovalsManager.RemovedMember">
            <summary>
            Helper class used to report removed universe members
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData">
            <summary>
            Store data both raw and adjusted and the time at which it should be synchronized
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.DataNormalizationMode,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.PrecalculatedSubscriptionData"/> class
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="rawData">The base data</param>
            <param name="normalizedData">The normalized calculated based on raw data</param>
            <param name="normalizationMode">Specifies how data is normalized</param>
            <param name="emitTimeUtc">The emit time for the data</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider">
            <summary>
            Will generate time steps around the desired <see cref="T:QuantConnect.ITimeProvider"/>
            Provided step evaluator should return true when the next time step
            is valid and time can advance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider.#ctor(QuantConnect.ITimeProvider,System.Func{System.DateTime,System.Boolean})">
            <summary>
            Creates a new instance
            </summary>
            <param name="underlyingTimeProvider">The timer provider instance to wrap</param>
            <param name="customStepEvaluator">Function to evaluate whether or not
            to advance time. Should return true if provided <see cref="T:System.DateTime"/> is a
            valid new next time. False will avoid time advancing</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.PredicateTimeProvider.GetUtcNow">
            <summary>
            Gets the current utc time step
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue">
            <summary>
            Live Data Queue is the cut out implementation of how to bind a custom live data source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Subscribe(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Desktop/Local doesn't support live data from this handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Unsubscribe(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Desktop/Local doesn't support live data from this handler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.SetJob(QuantConnect.Packets.LiveNodePacket)">
            <summary>
            Sets the job we're subscribing for
            </summary>
            <param name="job">Job we're subscribing for</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.IsConnected">
            <summary>
            Returns whether the data provider is connected
            </summary>
            <returns>true if the data provider is connected</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue">
            <summary>
            This is an implementation of <see cref="T:QuantConnect.Interfaces.IDataQueueHandler"/> used for testing
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.TimeProvider">
            <summary>
            Continuous UTC time provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue"/> class to randomly emit data for each symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.#ctor(QuantConnect.Data.IDataAggregator)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue"/> class to randomly emit data for each symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Subscribe(QuantConnect.Data.SubscriptionDataConfig,System.EventHandler)">
            <summary>
            Subscribe to the specified configuration
            </summary>
            <param name="dataConfig">defines the parameters to subscribe to a data feed</param>
            <param name="newDataAvailableHandler">handler to be fired on new data available</param>
            <returns>The new enumerator for this subscription request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.SetJob(QuantConnect.Packets.LiveNodePacket)">
            <summary>
            Sets the job we're subscribing for
            </summary>
            <param name="job">Job we're subscribing for</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Unsubscribe(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Removes the specified configuration
            </summary>
            <param name="dataConfig">Subscription config to be removed</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.IsConnected">
            <summary>
            Returns whether the data provider is connected
            </summary>
            <returns>true if the data provider is connected</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.PopulateQueue">
            <summary>
            Pumps a bunch of ticks into the queue
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs">
            <summary>
            Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError"/> event.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.Line">
            <summary>
            Gets the line that caused the error
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.Exception">
            <summary>
            Gets the exception that was caught
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs"/> class
            </summary>
            <param name="line">The line that caused the error</param>
            <param name="exception">The exception that was caught during the read</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService">
            <summary>
            Allows to setup a real time scheduled event, internally using a <see cref="T:System.Threading.Timer"/>,
            that is guaranteed to trigger at or after the requested time, never before.
            </summary>
            <remarks>This class is of value because <see cref="T:System.Threading.Timer"/> could fire the
            event before time.</remarks>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.NewEvent">
            <summary>
            Event fired when the scheduled time is past
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.#ctor(QuantConnect.ITimeProvider)">
            <summary>
            Creates a new instance
            </summary>
            <param name="timeProvider">The time provider to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.ScheduleEvent(System.TimeSpan,System.DateTime)">
            <summary>
            Schedules a new event
            </summary>
            <param name="dueTime">The desired due time</param>
            <param name="utcNow">Current utc time</param>
            <remarks>Scheduling a new event will try to disable previous scheduled event,
            but it is not guaranteed.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeScheduleEventService.Dispose">
            <summary>
            Disposes of the underlying <see cref="T:System.Threading.Timer"/> instance
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider">
            <summary>
            Default implementation of the <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/>
            Does not cache data.  If the data is a zip, the first entry is returned
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.IsDataEphemeral">
            <summary>
            Property indicating the data is temporary in nature and should not be cached.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.#ctor(QuantConnect.Interfaces.IDataProvider,System.Boolean)">
            <summary>
            Constructor that takes the <see cref="T:QuantConnect.Interfaces.IDataProvider"/> to be used to retrieve data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.Fetch(System.String)">
            <summary>
            Fetch data from the cache
            </summary>
            <param name="key">A string representing the key of the cached data</param>
            <returns>An <see cref="T:System.IO.Stream"/> of the cached data</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.Store(System.String,System.Byte[])">
            <summary>
            Not implemented
            </summary>
            <param name="key">The source of the data, used as a key to retrieve data in the cache</param>
            <param name="data">The data to cache as a byte array</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SingleEntryDataCacheProvider.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Subscription">
            <summary>
            Represents the data required for a data feed to process a single subscription
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Subscription.NewDataAvailable">
            <summary>
            Event fired when a new data point is available
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Universes">
            <summary>
            Gets the universe for this subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Subscription.Security">
            <summary>
            Gets the security this subscription points to
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Subscription.Configuration">
            <summary>
            Gets the configuration for this subscritions
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.TimeZone">
            <summary>
            Gets the exchange time zone associated with this subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Subscription.OffsetProvider">
            <summary>
            Gets the offset provider for time zone conversions to and from the data's local time
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.RealtimePrice">
            <summary>
            Gets the most current value from the subscription source
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.EndOfStream">
            <summary>
            Gets true if this subscription is finished, false otherwise
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.IsUniverseSelectionSubscription">
            <summary>
            Gets true if this subscription is used in universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.UtcStartTime">
            <summary>
            Gets the start time of this subscription in UTC
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.UtcEndTime">
            <summary>
            Gets the end time of this subscription in UTC
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.RemovedFromUniverse">
            <summary>
            Gets whether or not this subscription has been removed from its parent universe
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.#ctor(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Lean.Engine.DataFeeds.SubscriptionData},QuantConnect.TimeZoneOffsetProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> class with a universe
            </summary>
            <param name="subscriptionRequest">Specified for universe subscriptions</param>
            <param name="enumerator">The subscription's data source</param>
            <param name="timeZoneOffsetProvider">The offset provider used to convert data local times to utc</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.AddSubscriptionRequest(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
            <summary>
            Adds a <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> for this subscription
            </summary>
            <param name="subscriptionRequest">The <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> to add</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.RemoveSubscriptionRequest(QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Removes one or all <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/> from this subscription
            </summary>
            <param name="universe">Universe requesting to remove <see cref="T:QuantConnect.Data.UniverseSelection.SubscriptionRequest"/>.
            Default value, null, will remove all universes</param>
            <returns>True, if the subscription is empty and ready to be removed</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.MarkAsRemovedFromUniverse">
            <summary>
            Mark this subscription as having been removed from the universe.
            Data for this time step will be discarded.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object. </param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.OnNewDataAvailable">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Subscription.NewDataAvailable"/> event
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection">
            <summary>
            Provides a collection for holding subscriptions.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.Contains(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Checks the collection for the specified subscription configuration
            </summary>
            <param name="configuration">The subscription configuration to check for</param>
            <returns>True if a subscription with the specified configuration is found in this collection, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryAdd(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Attempts to add the specified subscription to the collection. If another subscription
            exists with the same configuration then it won't be added.
            </summary>
            <param name="subscription">The subscription to add</param>
            <returns>True if the subscription is successfully added, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryGetValue(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Lean.Engine.DataFeeds.Subscription@)">
            <summary>
            Attempts to retrieve the subscription with the specified configuration
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="subscription">The subscription matching the configuration, null if not found</param>
            <returns>True if the subscription is successfully retrieved, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryRemove(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Lean.Engine.DataFeeds.Subscription@)">
            <summary>
            Attempts to remove the subscription with the specified configuraton from the collection.
            </summary>
            <param name="configuration">The configuration of the subscription to remove</param>
            <param name="subscription">The removed subscription, null if not found.</param>
            <returns>True if the subscription is successfully removed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.UpdateAndGetFillForwardResolution(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets and updates the fill forward resolution by checking specified subscription configurations and
            selecting the smallest resoluton not equal to tick
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.ValidateFillForwardResolution(QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Helper method to validate a configuration to be included in the fill forward calculation
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.UpdateFillForwardResolution(QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.FillForwardResolutionOperation,QuantConnect.Data.SubscriptionDataConfig)">
            <summary>
            Gets and updates the fill forward resolution by checking specified subscription configurations and
            selecting the smallest resoluton not equal to tick
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.SortSubscriptions">
            <summary>
            Sorts subscriptions so that equity subscriptions are enumerated before option
            securities to ensure the underlying data is available when we process the options data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData">
            <summary>
            Store data (either raw or adjusted) and the time at which it should be synchronized
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData._data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.Data">
            <summary>
            Gets the data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.EmitTimeUtc">
            <summary>
            Gets the UTC emit time for this data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.#ctor(QuantConnect.Data.BaseData,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData"/> class
            </summary>
            <param name="data">The base data</param>
            <param name="emitTimeUtc">The emit time for the data</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData.Create(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SecurityExchangeHours,QuantConnect.TimeZoneOffsetProvider,QuantConnect.Data.BaseData,QuantConnect.DataNormalizationMode,System.Nullable{System.Decimal})">
            <summary>
            Clones the data, computes the utc emit time and performs exchange round down behavior, storing the result in a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData"/> instance
            </summary>
            <param name="configuration">The subscription's configuration</param>
            <param name="exchangeHours">The exchange hours of the security</param>
            <param name="offsetProvider">The subscription's offset provider</param>
            <param name="data">The data being emitted</param>
            <param name="normalizationMode">Specifies how data is normalized</param>
            <param name="factor">price scale factor</param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionData"/> containing the specified data</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader">
            <summary>
            Subscription data reader is a wrapper on the stream reader class to download, unpack and iterate over a data file.
            </summary>
            <remarks>The class accepts any subscription configuration and automatically makes it available to enumerate</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._config">
            Configuration of the data-reader:
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._hasScaleFactors">
            true if we can find a scale factor file for the security of the form: ..\Lean\Data\equity\market\factor_files\{SYMBOL}.csv
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.InvalidConfigurationDetected">
            <summary>
            Event fired when an invalid configuration has been detected
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NumericalPrecisionLimited">
            <summary>
            Event fired when the numerical precision in the factor file has been limited
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.StartDateLimited">
            <summary>
            Event fired when the start date has been limited
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.DownloadFailed">
            <summary>
            Event fired when there was an error downloading a remote file
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ReaderErrorDetected">
            <summary>
            Event fired when there was an error reading the data
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate">
            <summary>
            Event fired when there is a new tradable date
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Current">
            <summary>
            Last read BaseData object from this type and source
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.System#Collections#IEnumerator#Current">
            <summary>
            Explicit Interface Implementation for Current
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.DateTime,QuantConnect.Data.Auxiliary.MapFileResolver,QuantConnect.Interfaces.IFactorFileProvider,System.Collections.Generic.IEnumerable{System.DateTime},System.Boolean,QuantConnect.Interfaces.IDataCacheProvider)">
            <summary>
            Subscription data reader takes a subscription request, loads the type, accepts the data source and enumerate on the results.
            </summary>
            <param name="config">Subscription configuration object</param>
            <param name="periodStart">Start date for the data request/backtest</param>
            <param name="periodFinish">Finish date for the data request/backtest</param>
            <param name="mapFileResolver">Used for resolving the correct map files</param>
            <param name="factorFileProvider">Used for getting factor files</param>
            <param name="dataCacheProvider">Used for caching files</param>
            <param name="tradeableDates">Defines the dates for which we'll request data, in order, in the security's data time zone</param>
            <param name="isLiveMode">True if we're in live mode, false otherwise</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Initialize">
            <summary>
            Initializes the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader"/> instance
            </summary>
            <remarks>Should be called after all consumers of <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate"/> event are set,
            since it will produce events.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.UpdateDataEnumerator(System.Boolean)">
            <summary>
            Resolves the next enumerator to be used in <see cref="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.MoveNext"/> and updates
            <see cref="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._subscriptionFactoryEnumerator"/>
            </summary>
            <returns>True, if the enumerator has been updated (even if updated to null)</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.TryGetNextDate(System.DateTime@)">
            <summary>
            Iterates the tradeable dates enumerator
            </summary>
            <param name="date">The next tradeable date</param>
            <returns>True if we got a new date from the enumerator, false if it's exhausted, or in live mode if we're already at today</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Reset">
            <summary>
            Reset the IEnumeration
            </summary>
            <remarks>Not used</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Dispose">
            <summary>
            Dispose of the Stream Reader and close out the source stream and file connections.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnInvalidConfigurationDetected(QuantConnect.InvalidConfigurationDetectedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.InvalidConfigurationDetected"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.InvalidConfigurationDetected"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnNumericalPrecisionLimited(QuantConnect.NumericalPrecisionLimitedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NumericalPrecisionLimited"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NumericalPrecisionLimited"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnStartDateLimited(QuantConnect.StartDateLimitedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.StartDateLimited"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.StartDateLimited"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnDownloadFailed(QuantConnect.DownloadFailedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.DownloadFailed"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.DownloadFailed"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnReaderErrorDetected(QuantConnect.ReaderErrorDetectedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ReaderErrorDetected"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ReaderErrorDetected"/> event</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.OnNewTradableDate(QuantConnect.NewTradableDateEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate"/> event
            </summary>
            <param name="e">Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.NewTradableDate"/> event</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader">
            <summary>
            Provides a factory method for creating <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> instances
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader.ForSource(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean,QuantConnect.Data.BaseData)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> capable of handling the specified <paramref name="source"/>
            </summary>
            <param name="source">The subscription data source to create a factory for</param>
            <param name="dataCacheProvider">Used to cache data</param>
            <param name="config">The configuration of the subscription</param>
            <param name="date">The date to be processed</param>
            <param name="isLiveMode">True for live mode, false otherwise</param>
            <param name="factory">The base data instance factory</param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> that can read the specified <paramref name="source"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader.CheckRemoteFileCache">
            <summary>
            Creates cache directory if not existing and deletes old files from the cache
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider">
            <summary>
            A time provider which updates 'now' time based on the current data emit time of all subscriptions
            </summary>
            <remarks>This class is not thread safe but there is no need for it to be since it's only consumed by the
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider.#ctor(System.DateTime,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Creates a new instance of the SubscriptionFrontierTimeProvider
            </summary>
            <param name="utcNow">Initial UTC now time</param>
            <param name="subscriptionManager">Subscription manager. Will be used to obtain current subscriptions</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider.GetUtcNow">
            <summary>
            Gets the current time in UTC
            </summary>
            <returns>The current time in UTC</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider.UpdateCurrentTime">
            <summary>
            Sets the current time calculated as the minimum current data emit time of all the subscriptions.
            If there are no subscriptions current time will remain unchanged
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer">
            <summary>
            Provides the ability to synchronize subscriptions into time slices
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SubscriptionFinished">
            <summary>
            Event fired when a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> is finished
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.#ctor(QuantConnect.Lean.Engine.DataFeeds.UniverseSelection)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer"/> class
            </summary>
            <param name="universeSelection">The universe selection instance used to handle universe
            selection subscription output</param>
            <returns>A time slice for the specified frontier time</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SetTimeProvider(QuantConnect.ITimeProvider)">
            <summary>
            Sets the time provider. If already set will throw.
            </summary>
            <param name="timeProvider">The time provider, used to obtain the current frontier UTC value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SetTimeSliceFactory(QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory)">
            <summary>
            Sets the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory"/> instance to use
            </summary>
            <param name="timeSliceFactory">Used to create the new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.Sync(System.Collections.Generic.IEnumerable{QuantConnect.Lean.Engine.DataFeeds.Subscription},System.Threading.CancellationToken)">
            <summary>
            Syncs the specified subscriptions. The frontier time used for synchronization is
            managed internally and dependent upon previous synchronization operations.
            </summary>
            <param name="subscriptions">The subscriptions to sync</param>
            <param name="cancellationToken">The cancellation token to stop enumeration</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.OnSubscriptionFinished(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SubscriptionFinished"/> event
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.GetUtcNow">
            <summary>
            Returns the current UTC frontier time
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils">
            <summary>
            Utilities related to data <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils.Create(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> which will directly consume the provided enumerator
            </summary>
            <param name="request">The subscription data request</param>
            <param name="enumerator">The data enumerator stack</param>
            <returns>A new subscription instance ready to consume</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils.CreateAndScheduleWorker(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Interfaces.IFactorFileProvider,System.Boolean)">
            <summary>
            Setups a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription"/> which will consume a blocking <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1"/>
            that will be feed by a worker task
            </summary>
            <param name="request">The subscription data request</param>
            <param name="enumerator">The data enumerator stack</param>
            <param name="factorFileProvider">The factor file provider</param>
            <param name="enablePriceScale">Enables price factoring</param>
            <returns>A new subscription instance ready to consume</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionUtils.GetFactorFileToUse(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Interfaces.IFactorFileProvider)">
            <summary>
            Gets <see cref="T:QuantConnect.Data.Auxiliary.FactorFile"/> for configuration
            </summary>
            <param name="config">Subscription configuration</param>
            <param name="factorFileProvider">The factor file provider</param>
            <returns></returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Synchronizer">
            <summary>
            Implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISynchronizer"/> interface which provides the mechanism to stream data to the algorithm
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.Algorithm">
            <summary>
            The algorithm instance
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.SubscriptionManager">
            <summary>
            The subscription manager
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.SubscriptionSynchronizer">
            <summary>
            The subscription synchronizer
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.TimeSliceFactory">
            <summary>
            The time slice factory
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.TimeProvider">
            <summary>
            Continuous UTC time provider, only valid for live trading see <see cref="T:QuantConnect.Lean.Engine.DataFeeds.LiveSynchronizer"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.FrontierTimeProvider">
            <summary>
            Time provider which returns current UTC frontier time
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Initializes the instance of the Synchronizer class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.StreamData(System.Threading.CancellationToken)">
            <summary>
            Returns an enumerable which provides the data to stream to the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.PostInitialize">
            <summary>
            Performs additional initialization steps after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.GetTimeProvider">
            <summary>
            Gets the <see cref="T:QuantConnect.ITimeProvider"/> to use. By default this will load the
            <see cref="T:QuantConnect.RealTimeProvider"/> for live mode, else <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionFrontierTimeProvider"/>
            </summary>
            <returns>The <see cref="T:QuantConnect.ITimeProvider"/> to use</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Synchronizer.Dispose">
            <summary>
            Free resources
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader">
            <summary>
            Provides an implementations of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> that uses the
            <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)"/>
            method to read lines of text from a <see cref="T:QuantConnect.Data.SubscriptionDataSource"/>
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError">
            <summary>
            Event fired when an exception is thrown during a call to
            <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)"/>
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.CreateStreamReaderError">
            <summary>
            Event fired when there's an error creating an <see cref="T:QuantConnect.Interfaces.IStreamReader"/> or the
            instantiated <see cref="T:QuantConnect.Interfaces.IStreamReader"/> has no data.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader"/> class
            </summary>
            <param name="dataCacheProvider">This provider caches files if needed</param>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
            <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> that was invalid</param>
            <param name="exception">The exception if one was raised, otherwise null</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnReaderError(System.String,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError"/> event
            </summary>
            <param name="line">The line that caused the exception</param>
            <param name="exception">The exception that was caught</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnCreateStreamReaderError(System.DateTime,QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.CreateStreamReaderError"/> event
            </summary>
            <param name="date">The date of the source</param>
            <param name="source">The source that caused the error</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.SetCacheSize(System.Int32)">
            <summary>
            Set the cache size to use
            </summary>
            <remarks>How to size this cache: Take worst case scenario, BTCUSD hour, 60k QuoteBar entries, which are roughly 200 bytes in size -> 11 MB * CacheSize</remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice">
            <summary>
            Represents a grouping of data emitted at a certain time.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.DataPointCount">
            <summary>
            Gets the count of data points in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Time">
            <summary>
            Gets the UTC time this data was emitted
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Data">
            <summary>
            Gets the data in the time slice
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Slice">
            <summary>
            Gets the <see cref="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Slice"/> that will be used as input for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.SecuritiesUpdateData">
            <summary>
            Gets the data used to update securities
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.ConsolidatorUpdateData">
            <summary>
            Gets the data used to update the consolidators
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.CustomData">
            <summary>
            Gets all the custom data in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.SecurityChanges">
            <summary>
            Gets the changes to the data subscriptions as a result of universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.UniverseData">
            <summary>
            Gets the universe data generated this time step.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.IsTimePulse">
            <summary>
            True indicates this time slice is a time pulse for the algorithm containing no data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.#ctor(System.DateTime,System.Int32,QuantConnect.Data.Slice,System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Interfaces.ISecurityPrice}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Data.SubscriptionDataConfig}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Interfaces.ISecurityPrice}},QuantConnect.Data.UniverseSelection.SecurityChanges,System.Collections.Generic.Dictionary{QuantConnect.Data.UniverseSelection.Universe,QuantConnect.Data.UniverseSelection.BaseDataCollection},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> containing the specified data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory">
            <summary>
            Instance base class that will provide methods for creating new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory.#ctor(NodaTime.DateTimeZone)">
            <summary>
            Creates a new instance
            </summary>
            <param name="timeZone">The time zone required for computing algorithm and slice time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory.CreateTimePulse(System.DateTime)">
            <summary>
            Creates a new empty <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> to be used as a time pulse
            </summary>
            <remarks>The objective of this method is to standardize the time pulse creation</remarks>
            <param name="utcDateTime">The UTC frontier date time</param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> time pulse</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSliceFactory.Create(System.DateTime,System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket},QuantConnect.Data.UniverseSelection.SecurityChanges,System.Collections.Generic.Dictionary{QuantConnect.Data.UniverseSelection.Universe,QuantConnect.Data.UniverseSelection.BaseDataCollection})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> for the specified time using the specified data
            </summary>
            <param name="utcDateTime">The UTC frontier date time</param>
            <param name="data">The data in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/></param>
            <param name="changes">The new changes that are seen in this time slice as a result of universe selection</param>
            <param name="universeData"></param>
            <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice"/> containing the specified data</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader">
            <summary>
            Represents a stream reader capable of reading lines from disk
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="dataCacheProvider">The <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/> used to retrieve a stream of data</param>
            <param name="source">The local file to be read</param>
            <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
            or to open the first zip entry found regardless of name</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="dataCacheProvider">The <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/> used to retrieve a stream of data</param>
            <param name="source">The local file to be read</param>
            <param name="startingPosition">The position in the stream from which to start reading</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(Ionic.Zip.ZipFile,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="zipFile">The local zip archive to be read</param>
            <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
            or to open the first zip entry found regardless of name</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.EntryFileNames">
            <summary>
            Returns the list of zip entries if local file stream reader is reading zip archive
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.LocalFile"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.Dispose">
            <summary>
            Disposes of the stream
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader">
            <summary>
            Represents a stream reader capabable of downloading a remote file and then
            reading it from disk
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.#ctor(QuantConnect.Interfaces.IDataCacheProvider,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader"/> class.
            </summary>
            <param name="dataCacheProvider">The <see cref="T:QuantConnect.Interfaces.IDataCacheProvider"/> used to retrieve a stream of data</param>
            <param name="source">The remote url to be downloaded via web client</param>
            <param name="downloadDirectory">The local directory and destination of the download</param>
            <param name="headers">Defines header values to add to the request</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.RemoteFile"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.Dispose">
            <summary>
            Disposes of the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.SetDownloadProvider(QuantConnect.Interfaces.IDownloadProvider)">
            <summary>
            Save reference to the download system.
            </summary>
            <param name="downloader">Downloader provider for the remote file fetching.</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader">
            <summary>
            Represents a stream reader capable of polling a rest client
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.ShouldBeRateLimited">
            <summary>
            Gets whether or not this stream reader should be rate limited
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.StreamReader">
            <summary>
            Direct access to the StreamReader instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader"/> class.
            </summary>
            <param name="source">The source url to poll with a GET</param>
            <param name="headers">Defines header values to add to the request</param>
            <param name="isLiveMode">True for live mode, false otherwise</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.TransportMedium">
            <summary>
            Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.Rest"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.EndOfStream">
            <summary>
            Gets whether or not there's more data to be read in the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.ReadLine">
            <summary>
            Gets the next line/batch of content from the stream
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.Dispose">
            <summary>
            This stream reader doesn't require disposal
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection">
            <summary>
            Provides methods for apply the results of universe selection to an algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.#ctor(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.ISecurityService,QuantConnect.Interfaces.IDataPermissionManager,QuantConnect.Interfaces.IDataProvider,QuantConnect.Resolution)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection"/> class
            </summary>
            <param name="algorithm">The algorithm to add securities to</param>
            <param name="securityService">The security service</param>
            <param name="dataPermissionManager">The data permissions manager</param>
            <param name="dataProvider">The data provider to use</param>
            <param name="internalConfigResolution">The resolution to use for internal configuration</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.SetDataManager(QuantConnect.Lean.Engine.DataFeeds.IDataFeedSubscriptionManager)">
            <summary>
            Sets the data manager
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.ApplyUniverseSelection(QuantConnect.Data.UniverseSelection.Universe,System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Applies universe selection the the data feed and algorithm
            </summary>
            <param name="universe">The universe to perform selection on</param>
            <param name="dateTimeUtc">The current date time in utc</param>
            <param name="universeData">The data provided to perform selection with</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.AddPendingInternalDataFeeds(System.DateTime)">
            <summary>
            Will add any pending internal currency subscriptions
            </summary>
            <param name="utcStart">The current date time in utc</param>
            <returns>Will return true if any subscription was added</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.EnsureCurrencyDataFeeds(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Checks the current subscriptions and adds necessary currency pair feeds to provide real time conversion data
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1">
            <summary>
            Transport type for algorithm update data. This is intended to provide a
            list of base data used to perform updates against the specified target
            </summary>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.ContainsFillForwardData">
            <summary>
            Flag indicating whether <see cref="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Data"/> contains any fill forward bar or not
            </summary>
            <remarks>This is useful for performance, it allows consumers to skip re enumerating the entire data
            list to filter any fill forward data</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Target">
            <summary>
            The target, such as a security or subscription data config
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Data">
            <summary>
            The data used to update the target
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.DataType">
            <summary>
            The type of data in the data list
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.IsInternalConfig">
            <summary>
            True if this update data corresponds to an internal subscription
            such as currency or security benchmark
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.#ctor(`0,System.Type,System.Collections.Generic.IReadOnlyList{QuantConnect.Data.BaseData},System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1"/> class
            </summary>
            <param name="target">The end consumer/user of the dat</param>
            <param name="dataType">The type of data in the list</param>
            <param name="data">The update data</param>
            <param name="isInternalConfig">True if this update data corresponds to an internal subscription
            such as currency or security benchmark</param>
            <param name="containsFillForwardData">True if this update data contains fill forward bars</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.IWorkQueue">
            <summary>
            Work queue abstraction
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.IWorkQueue.WorkerThread(System.Collections.Concurrent.ConcurrentQueue{QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem},System.Threading.AutoResetEvent)">
            <summary>
            This is the worker thread loop.
            It will first try to take a work item from the new work queue else will check his own queue.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.IWorkQueue.Sort">
            <summary>
            Sorts the work queue
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.IWorkQueue.ThreadPriority">
            <summary>
            Returns the thread priority to use for this work queue
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler">
            <summary>
            This singleton class will create a thread pool to processes work
            that will be prioritized based on it's weight
            </summary>
            <remarks>The threads in the pool will take ownership of the
            <see cref="T:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem"/> and not share it with another thread.
            This is required because the data enumerator stack yields, which state
            depends on the thread id</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.WorkBatchSize">
            <summary>
            This is the size of each work sprint
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.MaxWorkWeight">
            <summary>
            This is the maximum size a work item can weigh,
            if reached, it will be ignored and not executed until its less
            </summary>
            <remarks>This is useful to limit RAM and CPU usage</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WeightedWorkScheduler.QueueWork(System.Func{System.Int32,System.Boolean},System.Func{System.Int32})">
            <summary>
            Add a new work item to the queue
            </summary>
            <param name="workFunc">The work function to run</param>
            <param name="weightFunc">The weight function.
            Work will be sorted in ascending order based on this weight</param>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.Weight">
            <summary>
            The current weight
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.Work">
            <summary>
            The work function to execute
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.#ctor(System.Func{System.Int32,System.Boolean},System.Func{System.Int32})">
            <summary>
            Creates a new instance
            </summary>
            <param name="work">The work function, takes an int, the amount of work to do
            and returns a bool, false if this work item is finished</param>
            <param name="weightFunc">The function used to determine the current weight</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.UpdateWeight">
            <summary>
            Updates the weight of this work item
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem.Compare(QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem,QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem)">
            <summary>
            Compares two work items based on their weights
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue._workAvailableEvent">
            <summary>
            Event used to notify there is work ready to execute in this queue
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.ThreadPriority">
            <summary>
            Returns the thread priority to use for this work queue
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.Sort">
            <summary>
            Updates the weights and sorts the work in the queue
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.WorkerThread(System.Collections.Concurrent.ConcurrentQueue{QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem},System.Threading.AutoResetEvent)">
            <summary>
            This is the worker thread loop.
            It will first try to take a work item from the new work queue else will check his own queue.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.Add(QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem)">
            <summary>
            Adds a new item to this work queue
            </summary>
            <param name="work">The work to add</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.Remove(QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkItem)">
            <summary>
            Removes an item from the work queue
            </summary>
            <param name="workItem">The work item to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.WorkScheduling.WorkQueue.Get">
            <summary>
            Gets the next work item to execute, null if none is available
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider">
            <summary>
            File provider implements optimized zip archives caching facility. Cache is thread safe.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.IsDataEphemeral">
            <summary>
            Property indicating the data is temporary in nature and should not be cached.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.#ctor(QuantConnect.Interfaces.IDataProvider,System.Boolean)">
            <summary>
            Constructor that sets the <see cref="T:QuantConnect.Interfaces.IDataProvider"/> used to retrieve data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Fetch(System.String)">
            <summary>
            Does not attempt to retrieve any data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Store(System.String,System.Byte[])">
            <summary>
            Store the data in the cache. Not implemented in this instance of the IDataCacheProvider
            </summary>
            <param name="key">The source of the data, used as a key to retrieve data in the cache</param>
            <param name="data">The data as a byte array</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CleanCache">
            <summary>
            Remove items in the cache that are older than the cutoff date
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CreateStream(QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile,System.String,System.String)">
            <summary>
            Create a stream of a specific ZipEntry
            </summary>
            <param name="zipFile">The zipFile containing the zipEntry</param>
            <param name="entryName">The name of the entry</param>
            <param name="fileName">The name of the zip file on disk</param>
            <returns>A <see cref="T:System.IO.Stream"/> of the appropriate zip entry</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile">
            <summary>
            Type for storing zipfile in cache
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile._zipFile">
            <summary>
            The ZipFile this object represents
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.EntryCache">
            <summary>
            Contains all entries of the zip file by filename
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Disposed">
            <summary>
            Returns if this cached zip file is disposed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.#ctor(System.IO.Stream,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile"/>
            </summary>
            <param name="dataStream">Stream containing the zip file</param>
            <param name="utcNow">Current utc time</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Uncache(System.DateTime)">
            <summary>
            Method used to check if this object was created before a certain time
            </summary>
            <param name="date">DateTime which is compared to the DateTime this object was created</param>
            <returns>Bool indicating whether this object is older than the specified time</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipDataCacheProvider.CachedZipFile.Dispose">
            <summary>
            Dispose of the ZipFile
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader"/> that reads zip entry names
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.InvalidSource">
            <summary>
            Event fired when the specified source is considered invalid, this may
            be from a missing file or failure to download a remote source
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader"/> class
            </summary>
            <param name="config">The subscription's configuration</param>
            <param name="date">The date this factory was produced to read data for</param>
            <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Reads the specified <paramref name="source"/>
            </summary>
            <param name="source">The source to be read</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the data in the source</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.InvalidSource"/> event
            </summary>
            <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> that was invalid</param>
            <param name="exception">The exception if one was raised, otherwise null</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Engine">
             <summary>
             LEAN ALGORITHMIC TRADING ENGINE: ENTRY POINT.
            
             The engine loads new tasks, create the algorithms and threads, and sends them
             to Algorithm Manager to be executed. It is the primary operating loop.
             </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Engine.SystemHandlers">
            <summary>
            Gets the configured system handlers for this engine instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Engine.AlgorithmHandlers">
            <summary>
            Gets the configured algorithm handlers for this engine instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.#ctor(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Engine"/> class using the specified handlers
            </summary>
            <param name="systemHandlers">The system handlers for controlling acquisition of jobs, messaging, and api calls</param>
            <param name="algorithmHandlers">The algorithm handlers for managing algorithm initialization, data, results, transaction, and real time events</param>
            <param name="liveMode">True when running in live mode, false otherwise</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.Run(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.AlgorithmManager,System.String,QuantConnect.Util.WorkerThread)">
            <summary>
            Runs a single backtest/live job from the job queue
            </summary>
            <param name="job">The algorithm job to be processed</param>
            <param name="manager">The algorithm manager instance</param>
            <param name="assemblyPath">The path to the algorithm's assembly</param>
            <param name="workerThread">The worker thread instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.HandleAlgorithmError(QuantConnect.Packets.AlgorithmNodePacket,System.Exception)">
            <summary>
            Handle an error in the algorithm.Run method.
            </summary>
            <param name="job">Job we're processing</param>
            <param name="err">Error from algorithm stack</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.GetHistoryProvider(System.String)">
            <summary>
            Load the history provider from the Composer
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.SaveListOfTrades(QuantConnect.Securities.IOrderProvider,System.String)">
            <summary>
            Save a list of trades to disk for a given path
            </summary>
            <param name="transactions">Transactions list via an OrderProvider</param>
            <param name="csvFileName">File path to create</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.StaticInitializations">
            <summary>
            Initialize slow static variables
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/> that relies on
            a brokerage connection to retrieve historical data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider.SetBrokerage(QuantConnect.Interfaces.IBrokerage)">
            <summary>
            Sets the brokerage to be used for historical requests
            </summary>
            <param name="brokerage">The brokerage instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.BrokerageHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider">
            <summary>
            Implements a History provider that always return a IEnumerable of Slice with prices following a sine function
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.#ctor(QuantConnect.Securities.SecurityManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider"/> class
            </summary>
            <param name="securities">Collection of securities that a history request can return</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SineHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/> that uses <see cref="T:QuantConnect.Data.BaseData"/>
            instances to retrieve historical data
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.Initialize(QuantConnect.Data.HistoryProviderInitializeParameters)">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="parameters">The initialization parameters</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.CreateSubscription(QuantConnect.Data.HistoryRequest,System.DateTime,System.DateTime)">
            <summary>
            Creates a subscription to process the request
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.GetIntradayDataEnumerator(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Data.HistoryRequest)">
            <summary>
            Gets the intraday data enumerator if any
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider">
            <summary>
            Provides an abstract implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider"/>
            which provides synchronization of multiple history results
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.CreateSliceEnumerableFromSubscriptions(System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.Subscription},NodaTime.DateTimeZone)">
            <summary>
            Enumerates the subscriptions into slices
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SynchronizingHistoryProvider.CreateSubscription(QuantConnect.Data.HistoryRequest,System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData})">
            <summary>
            Creates a subscription to process the history request
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers">
            <summary>
            Provides a container for the algorithm specific handlers
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Results">
            <summary>
            Gets the result handler used to communicate results from the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Setup">
            <summary>
            Gets the setup handler used to initialize the algorithm state
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataFeed">
            <summary>
            Gets the data feed handler used to provide data to the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Transactions">
            <summary>
            Gets the transaction handler used to process orders from the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.RealTime">
            <summary>
            Gets the real time handler used to process real time events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.MapFileProvider">
            <summary>
            Gets the map file provider used as a map file source for the data feed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.FactorFileProvider">
            <summary>
            Gets the map file provider used as a map file source for the data feed
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataProvider">
            <summary>
            Gets the data file provider used to retrieve security data if it is not on the file system
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Alphas">
            <summary>
            Gets the alpha handler used to process algorithm generated insights
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.ObjectStore">
            <summary>
            Gets the object store used for persistence
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataPermissionsManager">
            <summary>
            Entity in charge of handling data permissions
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.#ctor(QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataProvider,QuantConnect.Lean.Engine.Alpha.IAlphaHandler,QuantConnect.Interfaces.IObjectStore,QuantConnect.Interfaces.IDataPermissionManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers"/> class from the specified handlers
            </summary>
            <param name="results">The result handler for communicating results from the algorithm</param>
            <param name="setup">The setup handler used to initialize algorithm state</param>
            <param name="dataFeed">The data feed handler used to pump data to the algorithm</param>
            <param name="transactions">The transaction handler used to process orders from the algorithm</param>
            <param name="realTime">The real time handler used to process real time events</param>
            <param name="mapFileProvider">The map file provider used to retrieve map files for the data feed</param>
            <param name="factorFileProvider">Map file provider used as a map file source for the data feed</param>
            <param name="dataProvider">file provider used to retrieve security data if it is not on the file system</param>
            <param name="alphas">The alpha handler used to process generated insights</param>
            <param name="objectStore">The object store used for persistence</param>
            <param name="dataPermissionsManager">The data permission manager to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.FromConfiguration(QuantConnect.Util.Composer)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers"/> class from the specified composer using type names from configuration
            </summary>
            <param name="composer">The composer instance to obtain implementations from</param>
            <returns>A fully hydrates <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> instance.</returns>
            <exception cref="T:System.ComponentModel.Composition.CompositionException">Throws a CompositionException during failure to load</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers">
            <summary>
            Provides a container for the system level handlers
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Api">
            <summary>
            Gets the api instance used for communicating algorithm limits, status, and storing of log data
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Notify">
            <summary>
            Gets the messaging handler instance used for communicating various packets to listeners, including
            debug/log messages, email/sms/web messages, as well as results and run time errors
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.JobQueue">
            <summary>
            Gets the job queue responsible for acquiring and acknowledging an algorithm job
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.LeanManager">
            <summary>
            Gets the ILeanManager implementation using to enhance the hosting environment
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.#ctor(QuantConnect.Interfaces.IJobQueueHandler,QuantConnect.Interfaces.IApi,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Lean.Engine.Server.ILeanManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> class with the specified handles
            </summary>
            <param name="jobQueue">The job queue used to acquire algorithm jobs</param>
            <param name="api">The api instance used for communicating limits and status</param>
            <param name="notify">The messaging handler user for passing messages from the algorithm to listeners</param>
            <param name="leanManager"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.FromConfiguration(QuantConnect.Util.Composer)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> class from the specified composer using type names from configuration
            </summary>
            <param name="composer">The composer instance to obtain implementations from</param>
            <returns>A fully hydrates <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers"/> instance.</returns>
            <exception cref="T:System.ComponentModel.Composition.CompositionException">Throws a CompositionException during failure to load</exception>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Initialize">
            <summary>
            Initializes the Api, Messaging, and JobQueue components
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler">
            <summary>
            Pseudo realtime event processing for backtesting to simulate realtime events in fast forward.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.IsActive">
            <summary>
            Flag indicating the hander thread is completely finished and ready to dispose.
            this doesn't run as its own thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Remove(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Removes the specified event from the schedule
            </summary>
            <param name="scheduledEvent">The event to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the time for the realtime event handler.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Exit">
            <summary>
            Stop the real time thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.SortFirstElement(System.Collections.Generic.IList{QuantConnect.Scheduling.ScheduledEvent})">
            <summary>
            Sorts the first element of the provided list and supposes the rest of the collection is sorted.
            Supposes the collection has at least 1 element
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler">
            <summary>
            Base class for the real time handler <see cref="T:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler"/>
            and <see cref="T:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler"/> implementations
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler._algorithmOnEndOfDay">
            <summary>
            Keep track of this event so we can remove it when we need to update it
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler._securityOnEndOfDay">
            <summary>
            Keep a separate track of these scheduled events so we can remove them
            if the security gets removed
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.ScheduledEvents">
            <summary>
            The scheduled events container
            </summary>
            <remarks>Initialize this immediately since the Initialize method gets
            called after IAlgorithm.Initialize, so we want to be ready to accept
            events as soon as possible</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Algorithm">
            <summary>
            The algorithm instance
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.ResultHandler">
            <summary>
            The result handler instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times
            the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Remove(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Removes the specified event from the schedule
            </summary>
            <param name="scheduledEvent">The event to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.Setup(System.DateTime,System.DateTime,QuantConnect.Language,System.Nullable{System.DateTime})">
            <summary>
            Initializes the real time handler for the specified algorithm and job.
            Adds EndOfDayEvents
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.GetScheduledEventUniqueId">
            <summary>
            Gets a new scheduled event unique id
            </summary>
            <remarks>This value is used to order scheduled events in a deterministic way</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.AddAlgorithmEndOfDayEvent(System.DateTime,System.DateTime,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market close by the specified time
            </summary>
            <param name="start">The date to start the events</param>
            <param name="end">The date to end the events</param>
            <param name="currentUtcTime">Specifies the current time in UTC, before which,
            no events will be scheduled. Specify null to skip this filter.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.AddSecurityDependentEndOfDayEvents(System.Collections.Generic.IEnumerable{QuantConnect.Securities.Security},System.DateTime,System.DateTime,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market
            close by the specified time for each provided securities.
            </summary>
            <param name="securities">The securities for which we want to add the OnEndOfDay event</param>
            <param name="start">The date to start the events</param>
            <param name="end">The date to end the events</param>
            <param name="currentUtcTime">Specifies the current time in UTC, before which,
            no events will be scheduled. Specify null to skip this filter.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BaseRealTimeHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler">
            <summary>
            Real time event handler, trigger functions at regular or pretimed intervals
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.IsActive">
            <summary>
            Thread status flag.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the current time for the event scanner (so we can use same code for backtesting and live events)
            </summary>
            <param name="time">Current real or backtest time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Exit">
            <summary>
            Trigger and exit signal to terminate real time event scanner.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler">
            <summary>
            Live trading realtime event processing.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.IsActive">
            <summary>
            Boolean flag indicating thread state.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi,QuantConnect.IIsolatorLimitResultProvider)">
            <summary>
            Initializes the real time handler for the specified algorithm and job
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Run">
            <summary>
            Execute the live realtime event thread montioring.
            It scans every second monitoring for an event trigger.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.RefreshMarketHoursToday(System.DateTime)">
            <summary>
            Refresh the Today variable holding the market hours information
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Remove(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Removes the specified event from the schedule
            </summary>
            <param name="scheduledEvent">The event to be removed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.SetTime(System.DateTime)">
            <summary>
            Set the current time. If the date changes re-start the realtime event setup routines.
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.ScanPastEvents(System.DateTime)">
            <summary>
            Scan for past events that didn't fire because there was no data at the scheduled time.
            </summary>
            <param name="time">Current time.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Exit">
            <summary>
            Stop the real time thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.MarketToday(System.DateTime,QuantConnect.Symbol)">
            <summary>
            Get the calendar open hours for the date.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory">
            <summary>
            Provides methods for creating common scheduled events
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EveryDayAt(System.String,System.Collections.Generic.IEnumerable{System.DateTime},System.TimeSpan,System.Action{System.String,System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire at the specified <paramref name="timeOfDay"/> for every day in
            <paramref name="dates"/>
            </summary>
            <param name="name">An identifier for this event</param>
            <param name="dates">The dates to set events for at the specified time. These act as a base time to which
            the <paramref name="timeOfDay"/> is added to, that is, the implementation does not use .Date before
            the addition</param>
            <param name="timeOfDay">The time each tradeable date to fire the event</param>
            <param name="callback">The delegate to call when an event fires</param>
            <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
            <returns>A new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> instance that fires events each tradeable day from the start to the finish at the specified time</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EveryAlgorithmEndOfDay(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,System.DateTime,System.DateTime,System.TimeSpan,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market close by the specified time
            </summary>
            <param name="algorithm">The algorithm instance the event is fo</param>
            <param name="resultHandler">The result handler, used to communicate run time errors</param>
            <param name="start">The date to start the events</param>
            <param name="end">The date to end the events</param>
            <param name="endOfDayDelta">The time difference between the market close and the event, positive time will fire before market close</param>
            <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
            <returns>The new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire near market close each tradeable dat</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EverySecurityEndOfDay(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Securities.Security,System.DateTime,System.DateTime,System.TimeSpan,System.Nullable{System.DateTime})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire before market close by the specified time
            </summary>
            <param name="algorithm">The algorithm instance the event is fo</param>
            <param name="resultHandler">The result handler, used to communicate run time errors</param>
            <param name="security">The security used for defining tradeable dates</param>
            <param name="start">The first date for the events</param>
            <param name="end">The date to end the events</param>
            <param name="endOfDayDelta">The time difference between the market close and the event, positive time will fire before market close</param>
            <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
            <returns>The new <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> that will fire near market close each tradeable dat</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.CreateEventName(System.String,System.String)">
            <summary>
            Defines the format of event names generated by this system.
            </summary>
            <param name="scope">The scope of the event, example, 'Algorithm' or 'Security'</param>
            <param name="name">A name for this specified event in this scope, example, 'EndOfDay'</param>
            <returns>A string representing a fully scoped event name</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.BacktestingResultHandler">
            <summary>
            Backtesting result handler passes messages back from the Lean to the User.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.FinalStatistics">
            <summary>
            A dictionary containing summary statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="job">Algorithm job packet for this result handler</param>
            <param name="messagingHandler">The handler responsible for communicating messages to listeners</param>
            <param name="api">The api instance used for handling logs</param>
            <param name="transactionHandler">The transaction handler used to get the algorithms <see cref="T:QuantConnect.Orders.Order"/> information</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Run">
            <summary>
            The main processing method steps through the messaging queue and processes the messages one by one.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Update">
            <summary>
            Send a backtest update to the browser taking a latest snapshot of the charting data.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SplitPackets(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.String,System.String},System.Decimal,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Run over all the data and break it into smaller packets to ensure they all arrive at the terminal
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.StoreResult(QuantConnect.Packets.Packet)">
            <summary>
            Save the snapshot of the total results to storage.
            </summary>
            <param name="packet">Packet to store.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SendFinalResult">
            <summary>
            Send a final analysis result back to the IDE.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Set the Algorithm instance for ths result.
            </summary>
            <param name="algorithm">Algorithm we're working on.</param>
            <param name="startingPortfolioValue">Algorithm starting capital for statistics calculations</param>
            <remarks>While setting the algorithm the backtest result handler.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.DebugMessage(System.String)">
            <summary>
            Send a debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Send a system debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.LogMessage(System.String)">
            <summary>
            Send a logging message to the log list for storage.
            </summary>
            <param name="message">Message we'd in the log.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send list of security asset types the algortihm uses to browser.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser highlighted in red with a stacktrace.
            </summary>
            <param name="message">Error message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error message back to the browser highlighted with in red
            </summary>
            <param name="message">Error message.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
            <summary>
            Add a sample to the chart specified by the chartName, and seriesName.
            </summary>
            <param name="chartName">String chart name to place the sample.</param>
            <param name="seriesIndex">Type of chart we should create if it doesn't already exist.</param>
            <param name="seriesName">Series name for the chart.</param>
            <param name="seriesType">Series type for the chart.</param>
            <param name="time">Time for the sample</param>
            <param name="unit">Unit of the sample</param>
            <param name="value">Value for the chart sample.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleEquity(System.DateTime,System.Decimal)">
            <summary>
            Sample the current equity of the strategy directly with time-value pair.
            </summary>
            <param name="time">Current backtest time.</param>
            <param name="value">Current equity value.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleRange(System.Collections.Generic.List{QuantConnect.Chart})">
            <summary>
            Add a range of samples from the users algorithms to the end of our current list.
            </summary>
            <param name="updates">Chart updates since the last request.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Send an algorithm status update to the browser.
            </summary>
            <param name="status">Status enum value.</param>
            <param name="message">Additional optional status message.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set the current runtime statistics of the algorithm.
            These are banner/title statistics which show at the top of the live trading results.
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Process the synchronous result events, sampling and message reading.
            This method is triggered from the algorithm manager thread.
            </summary>
            <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ConfigureConsoleTextWriter(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Configures the <see cref="P:System.Console.Out"/> and <see cref="P:System.Console.Error"/> <see cref="T:System.IO.TextWriter"/>
            instances. By default, we forward <see cref="M:System.Console.WriteLine(System.String)"/> to <see cref="M:QuantConnect.Interfaces.IAlgorithm.Debug(System.String)"/>.
            This is perfect for running in the cloud, but since they're processed asynchronously, the ordering of these
            messages with respect to <see cref="T:QuantConnect.Logging.Log"/> messages is broken. This can lead to differences in regression
            test logs based solely on the ordering of messages. To disable this forwarding, set <code>"forward-console-messages"</code>
            to <code>false</code> in the configuration.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.BaseResultsHandler">
            <summary>
            Provides base functionality to the implementations of <see cref="T:QuantConnect.Lean.Engine.Results.IResultHandler"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.MainUpdateInterval">
            <summary>
            The main loop update interval
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ChartUpdateInterval">
            <summary>
            The chart update interval
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.LastDeltaOrderPosition">
            <summary>
            The last position consumed from the <see cref="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents"/> by <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetDeltaOrders(System.Int32,System.Func{System.Int32,System.Boolean})"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.LastDeltaOrderEventsPosition">
            <summary>
            The last position consumed from the <see cref="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents"/> while determining delta order events
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler._updateRunner">
            <summary>
            The task in charge of running the <see cref="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Run"/> update method
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.IsActive">
            <summary>
            Boolean flag indicating the thread is still active.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Messages">
            <summary>
            Live packet messaging queue. Queue the messages here and send when the result queue is ready.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Charts">
            <summary>
            Storage for the price and equity charts of the live results.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ExitTriggered">
            <summary>
            True if the exit has been triggered
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ExitEvent">
            <summary>
            Event set when exit is triggered
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.LogStore">
            <summary>
            The log store instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AlgorithmPerformanceCharts">
            <summary>
            Algorithms performance related chart names
            </summary>
            <remarks>Used to calculate the probabilistic sharpe ratio</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ChartLock">
            <summary>
            Lock to be used when accessing the chart collection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ProjectId">
            <summary>
            The algorithm project id
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.RamAllocation">
            <summary>
            The maximum amount of RAM (in MB) this algorithm is allowed to utilize
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.CompileId">
            <summary>
            The algorithm unique compilation id
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AlgorithmId">
            <summary>
            The algorithm job id.
            This is the deploy id for live, backtesting id for backtesting
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StartTime">
            <summary>
            The result handler start time
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.RuntimeStatistics">
            <summary>
            Customizable dynamic statistics <see cref="P:QuantConnect.Interfaces.IAlgorithm.RuntimeStatistics"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.MessagingHandler">
            <summary>
            The handler responsible for communicating messages to listeners
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.TransactionHandler">
            <summary>
            The transaction handler used to get the algorithms Orders information
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StartingPortfolioValue">
            <summary>
            The algorithms starting portfolio value.
            Used to calculate the portfolio return
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Algorithm">
            <summary>
            The algorithm instance
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AlphaRuntimeStatistics">
            <summary>
            Gets or sets the current alpha runtime statistics
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.DailyPortfolioValue">
            <summary>
            Closing portfolio value. Used to calculate daily performance.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.PreviousUtcSampleTime">
            <summary>
            Last time the <see cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.DateTime,System.Boolean)"/> method was called in UTC
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ResamplePeriod">
            <summary>
            Sampling period for timespans between resamples of the charting equity.
            </summary>
            <remarks>Specifically critical for backtesting since with such long timeframes the sampled data can get extreme.</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.NotificationPeriod">
            <summary>
            How frequently the backtests push messages to the browser.
            </summary>
            <remarks>Update frequency of notification packets</remarks>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ResultsDestinationFolder">
            <summary>
            Directory location to store results
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BaseResultsHandler.OrderEventJsonConverter">
            <summary>
            The order event json converter instance to use
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            New order event for the algorithm
            </summary>
            <param name="newEvent">New event details</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetServerStatistics(System.DateTime)">
            <summary>
            Gets the current Server statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StoreOrderEvents(System.DateTime,System.Collections.Generic.List{QuantConnect.Orders.OrderEvent})">
            <summary>
            Stores the order events
            </summary>
            <param name="utcTime">The utc date associated with these order events</param>
            <param name="orderEvents">The order events to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetDeltaOrders(System.Int32,System.Func{System.Int32,System.Boolean})">
            <summary>
            Gets the orders generated starting from the provided <see cref="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents"/> position
            </summary>
            <returns>The delta orders</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="job">Algorithm job packet for this result handler</param>
            <param name="messagingHandler">The handler responsible for communicating messages to listeners</param>
            <param name="api">The api instance used for handling logs</param>
            <param name="transactionHandler">The transaction handler used to get the algorithms <see cref="T:QuantConnect.Orders.Order"/> information</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Run">
            <summary>
            Result handler update method
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetResultsPath(System.String)">
            <summary>
            Gets the full path for a results file
            </summary>
            <param name="filename">The filename to add to the path</param>
            <returns>The full path, including the filename</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SaveLogs(System.String,System.Collections.Generic.List{QuantConnect.Logging.LogEntry})">
            <summary>
            Returns the location of the logs
            </summary>
            <param name="id">Id that will be incorporated into the algorithm log name</param>
            <param name="logs">The logs to save</param>
            <returns>The path to the logs</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SaveResults(System.String,QuantConnect.Result)">
            <summary>
            Save the results to disk
            </summary>
            <param name="name">The name of the results</param>
            <param name="result">The results to save</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SetAlphaRuntimeStatistics(QuantConnect.AlphaRuntimeStatistics)">
            <summary>
            Sets the current alpha runtime statistics
            </summary>
            <param name="statistics">The current alpha runtime statistics</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.PurgeQueue">
            <summary>
            Purge/clear any outstanding messages in message queue.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StopUpdateRunner">
            <summary>
            Stops the update runner task
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetNetReturn">
            <summary>
            Gets the algorithm net return
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.StoreResult(QuantConnect.Packets.Packet)">
            <summary>
            Save the snapshot of the total results to storage.
            </summary>
            <param name="packet">Packet to store.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetPortfolioValue">
            <summary>
            Gets the current portfolio value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetBenchmarkValue">
            <summary>
            Gets the current benchmark value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Sample(System.DateTime,System.Boolean)">
            <summary>
            Samples portfolio equity, benchmark, and daily performance
            </summary>
            <param name="time">Current UTC time in the AlgorithmManager loop</param>
            <param name="force">Force sampling of equity, benchmark, and performance to be </param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleEquity(System.DateTime,System.Decimal)">
            <summary>
            Sample the current equity of the strategy directly with time-value pair.
            </summary>
            <param name="time">Time of the sample.</param>
            <param name="value">Current equity value.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SamplePerformance(System.DateTime,System.Decimal)">
            <summary>
            Sample the current daily performance directly with a time-value pair.
            </summary>
            <param name="time">Time of the sample.</param>
            <param name="value">Current daily performance value.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.SampleBenchmark(System.DateTime,System.Decimal)">
            <summary>
            Sample the current benchmark performance directly with a time-value pair.
            </summary>
            <param name="time">Time of the sample.</param>
            <param name="value">Current benchmark value.</param>
            <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.DateTime,System.Boolean)"/>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
            <summary>
            Add a sample to the chart specified by the chartName, and seriesName.
            </summary>
            <param name="chartName">String chart name to place the sample.</param>
            <param name="seriesName">Series name for the chart.</param>
            <param name="seriesIndex">Series chart index - which chart should this series belong</param>
            <param name="seriesType">Series type for the chart.</param>
            <param name="time">Time for the sample</param>
            <param name="value">Value for the chart sample.</param>
            <param name="unit">Unit for the chart axis</param>
            <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GetAlgorithmRuntimeStatistics(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Gets the algorithm runtime statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.GenerateStatisticsResults(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal})">
            <summary>
            Will generate the statistics results and update the provided runtime statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.AddToLogStore(System.String)">
            <summary>
            Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
            </summary>
            <param name="message">String message to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BaseResultsHandler.ProcessAlgorithmLogs(System.Nullable{System.Int32})">
            <summary>
            Processes algorithm logs.
            Logs of the same type are batched together one per line and are sent out
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.IResultHandler">
            <summary>
            Handle the results of the backtest: where should we send the profit, portfolio updates:
            Backtester or the Live trading platform:
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.Messages">
            <summary>
            Put messages to process into the queue so they are processed by this thread.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.IsActive">
            <summary>
            Boolean flag indicating the result hander thread is busy.
            False means it has completely finished and ready to dispose.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="job">Algorithm job packet for this result handler</param>
            <param name="messagingHandler">The messaging handler provider to use</param>
            <param name="api">The api implementation to use</param>
            <param name="transactionHandler"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.DebugMessage(System.String)">
            <summary>
            Process debug messages with the preconfigured settings.
            </summary>
            <param name="message">String debug message</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Process system debug messages with the preconfigured settings.
            </summary>
            <param name="message">String debug message</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send a list of security types to the browser
            </summary>
            <param name="types">Security types list inside algorithm</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.LogMessage(System.String)">
            <summary>
            Send a logging message to the log list for storage.
            </summary>
            <param name="message">Message we'd in the log.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser highlighted in red with a stacktrace.
            </summary>
            <param name="error">Error message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error message back to the browser highlighted with in red
            </summary>
            <param name="message">Error message.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.DateTime,System.Boolean)">
            <summary>
            Method to attempt to update the <see cref="T:QuantConnect.Lean.Engine.Results.IResultHandler"/> with various performance metrics.
            </summary>
            <param name="time">Current time</param>
            <param name="force">Forces a sampling event if true</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Set the algorithm of the result handler after its been initialized.
            </summary>
            <param name="algorithm">Algorithm object matching IAlgorithm interface</param>
            <param name="startingPortfolioValue">Algorithm starting capital for statistics calculations</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SetAlphaRuntimeStatistics(QuantConnect.AlphaRuntimeStatistics)">
            <summary>
            Sets the current alpha runtime statistics
            </summary>
            <param name="statistics">The current alpha runtime statistics</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Send a algorithm status update to the user of the algorithms running state.
            </summary>
            <param name="status">Status enum of the algorithm.</param>
            <param name="message">Optional string message describing reason for status change.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set a dynamic runtime statistic to show in the (live) algorithm header
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Send a new order event.
            </summary>
            <param name="newEvent">Update, processing or cancellation of an order, update the IDE in live mode or ignore in backtesting.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Process any synchronous events in here that are primarily triggered from the algorithm loop
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SaveResults(System.String,QuantConnect.Result)">
            <summary>
            Save the results
            </summary>
            <param name="name">The name of the results</param>
            <param name="result">The results to save</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler">
            <summary>
            Live trading result handler implementation passes the messages to the QC live trading interface.
            </summary>
            <remarks>Live trading result handler is quite busy. It sends constant price updates, equity updates and order/holdings updates.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
            <summary>
            Initialize the result handler with this result packet.
            </summary>
            <param name="job">Algorithm job packet for this result handler</param>
            <param name="messagingHandler">The handler responsible for communicating messages to listeners</param>
            <param name="api">The api instance used for handling logs</param>
            <param name="transactionHandler">The transaction handler used to get the algorithms Orders information</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Run">
            <summary>
            Live trading result handler thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Update">
            <summary>
            Every so often send an update to the browser with the current state of the algorithm.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreOrderEvents(System.DateTime,System.Collections.Generic.List{QuantConnect.Orders.OrderEvent})">
            <summary>
            Stores the order events
            </summary>
            <param name="utcTime">The utc date associated with these order events</param>
            <param name="orderEvents">The order events to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetOrderEventsToStore">
            <summary>
            Gets the order events generated in '_currentUtcDate'
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreStatusFile(System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,System.String},QuantConnect.Statistics.StatisticsResults)">
            <summary>
            Will store the complete status of the algorithm in a single json file
            </summary>
            <remarks>Will sample charts every 12 hours, 2 data points per day at maximum,
            to reduce file size</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SplitPackets(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},QuantConnect.Securities.CashBook,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.List{QuantConnect.Orders.OrderEvent})">
            <summary>
            Run over all the data and break it into smaller packets to ensure they all arrive at the terminal
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.DebugMessage(System.String)">
            <summary>
            Send a live trading debug message to the live console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
            <remarks>When there are already 500 messages in the queue it stops adding new messages.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Send a live trading system debug message to the live console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.LogMessage(System.String)">
            <summary>
            Log string messages and send them to the console.
            </summary>
            <param name="message">String message wed like logged.</param>
            <remarks>When there are already 500 messages in the queue it stops adding new messages.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.AddToLogStore(System.String)">
            <summary>
            Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
            </summary>
            <param name="message">String message to send to browser.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser console and highlight it read.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace to show in the console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send a list of secutity types that the algorithm trades to the browser to show the market clock - is this market open or closed!
            </summary>
            <param name="types">List of security types</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error back to the users browser and highlight it red.
            </summary>
            <param name="message">Runtime error message</param>
            <param name="stacktrace">Associated error stack trace.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
            <summary>
            Add a sample to the chart specified by the chartName, and seriesName.
            </summary>
            <param name="chartName">String chart name to place the sample.</param>
            <param name="seriesName">Series name for the chart.</param>
            <param name="seriesIndex">Series chart index - which chart should this series belong</param>
            <param name="seriesType">Series type for the chart.</param>
            <param name="time">Time for the sample</param>
            <param name="value">Value for the chart sample.</param>
            <param name="unit">Unit for the chart axis</param>
            <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleEquity(System.DateTime,System.Decimal)">
            <summary>
            Wrapper methond on sample to create the equity chart.
            </summary>
            <param name="time">Time of the sample.</param>
            <param name="value">Equity value at this moment in time.</param>
            <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)"/>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleRange(System.Collections.Generic.List{QuantConnect.Chart})">
            <summary>
            Add a range of samples from the users algorithms to the end of our current list.
            </summary>
            <param name="updates">Chart updates since the last request.</param>
            <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)"/>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Set the algorithm of the result handler after its been initialized.
            </summary>
            <param name="algorithm">Algorithm object matching IAlgorithm interface</param>
            <param name="startingPortfolioValue">Algorithm starting capital for statistics calculations</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Send a algorithm status update to the user of the algorithms running state.
            </summary>
            <param name="status">Status enum of the algorithm.</param>
            <param name="message">Optional string message describing reason for status change.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set a dynamic runtime statistic to show in the (live) algorithm header
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SendFinalResult">
            <summary>
            Send a final analysis result back to the IDE.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SaveLogs(System.String,System.Collections.Generic.List{QuantConnect.Logging.LogEntry})">
            <summary>
            Process the log entries and save it to permanent storage
            </summary>
            <param name="id">Id that will be incorporated into the algorithm log name</param>
            <param name="logs">Log list</param>
            <returns>Returns the location of the logs</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreResult(QuantConnect.Packets.Packet)">
            <summary>
            Save the snapshot of the total results to storage.
            </summary>
            <param name="packet">Packet to store.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            New order event for the algorithm
            </summary>
            <param name="newEvent">New event details</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures like sending final results
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Truncate(QuantConnect.Packets.LiveResult,System.DateTime,System.DateTime)">
            <summary>
            Truncates the chart and order data in the result packet to within the specified time frame
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.CreateSafeChartName(System.String)">
            <summary>
            Escape the chartname so that it can be saved to a file system
            </summary>
            <param name="chartName">The name of a chart</param>
            <returns>The name of the chart will all escape all characters except RFC 2396 unreserved characters</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Process the synchronous result events, sampling and message reading.
            This method is triggered from the algorithm manager thread.
            </summary>
            <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed.
            On Security change we re determine when should we sample charts, if the user added Crypto, Forex or an extended market hours subscription
            we will always sample charts. Else, we will keep the exchange per market to query later on demand
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.DateTime,System.Boolean)">
            <summary>
            Samples portfolio equity, benchmark, and daily performance
            </summary>
            <param name="time">Current UTC time in the AlgorithmManager loop</param>
            <param name="force">Force sampling of equity, benchmark, and performance to be </param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetPortfolioValue">
            <summary>
            Gets the current portfolio value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.GetBenchmarkValue">
            <summary>
            Gets the current benchmark value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.UserExchangeIsOpen(System.DateTime)">
            <summary>
            True if user exchange are open and we should update portfolio and benchmark value
            </summary>
            <remarks>Useful so that live trading implementation can freeze the returned value if there is no user exchange open
            so we ignore extended market hours updates</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.UpdateAlgorithmStatus">
            <summary>
            Will launch a task which will call the API and update the algorithm status every minute
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Results.RegressionResultHandler">
            <summary>
            Provides a wrapper over the <see cref="T:QuantConnect.Lean.Engine.Results.BacktestingResultHandler"/> that logs all order events
            to a separate file
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Results.RegressionResultHandler.LogFilePath">
            <summary>
            Gets the path used for logging all portfolio changing events, such as orders, TPV, daily holdings values
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Results.RegressionResultHandler"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm,System.Decimal)">
            <summary>
            Initializes the stream writer using the algorithm's id (name) in the file path
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SamplePerformance(System.DateTime,System.Decimal)">
            <summary>
            Runs on date changes, use this to log TPV and holdings values each day
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Log the order and order event to the dedicated log file for this regression algorithm
            </summary>
            <remarks>In backtesting the order events are not sent because it would generate a high load of messaging.</remarks>
            <param name="newEvent">New order event details</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SetAlphaRuntimeStatistics(QuantConnect.AlphaRuntimeStatistics)">
            <summary>
            Perform daily logging of the alpha runtime statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
            <summary>
            Send list of security asset types the algortihm uses to browser.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.DebugMessage(System.String)">
            <summary>
            Send a debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.ErrorMessage(System.String,System.String)">
            <summary>
            Send an error message back to the browser highlighted in red with a stacktrace.
            </summary>
            <param name="message">Error message we'd like shown in console.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.LogMessage(System.String)">
            <summary>
            Send a logging message to the log list for storage.
            </summary>
            <param name="message">Message we'd in the log.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.RuntimeError(System.String,System.String)">
            <summary>
            Send a runtime error message back to the browser highlighted with in red
            </summary>
            <param name="message">Error message.</param>
            <param name="stacktrace">Stacktrace information string</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SystemDebugMessage(System.String)">
            <summary>
            Send a system debug message back to the browser console.
            </summary>
            <param name="message">Message we'd like shown in console.</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.RuntimeStatistic(System.String,System.String)">
            <summary>
            Set the current runtime statistics of the algorithm.
            These are banner/title statistics which show at the top of the live trading results.
            </summary>
            <param name="key">Runtime headline statistic name</param>
            <param name="value">Runtime headline statistic value</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.AddToLogStore(System.String)">
            <summary>
            Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
            </summary>
            <param name="message">String message to store</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time that we add/remove securities from the data feed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.ProcessSynchronousEvents(System.Boolean)">
            <summary>
            Runs at the end of each time loop. When HighFidelityLogging is enabled, we'll
            log each piece of data to allow for faster determination of regression causes
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.SaveResults(System.String,QuantConnect.Result)">
            <summary>
            Save the results to disk
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.Exit">
            <summary>
            Terminate the result thread and apply any required exit procedures.
            Save orders log files to disk.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Results.RegressionResultHandler.ConfigureConsoleTextWriter(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            We want to make algorithm messages end up in both the standard regression log file {algorithm}.{language}.log
            as well as the details log {algorithm}.{language}.details.log. The details log is focused on providing a log
            dedicated solely to the algorithm's behavior, void of all <see cref="T:QuantConnect.Logging.Log"/> messages
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Server.ILeanManager">
            <summary>
            Provides scope into Lean that is convenient for managing a lean instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.Initialize(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.AlgorithmManager)">
            <summary>
            Initialize the ILeanManager implementation
            </summary>
            <param name="systemHandlers">Exposes lean engine system handlers running LEAN</param>
            <param name="algorithmHandlers">Exposes the lean algorithm handlers running lean</param>
            <param name="job">The job packet representing either a live or backtest Lean instance</param>
            <param name="algorithmManager">The Algorithm manager</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Sets the IAlgorithm instance in the ILeanManager
            </summary>
            <param name="algorithm">The IAlgorithm instance being run</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.Update">
            <summary>
            Update ILeanManager with the IAlgorithm instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.OnAlgorithmStart">
            <summary>
            This method is called after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.ILeanManager.OnAlgorithmEnd">
            <summary>
            This method is called before algorithm termination
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Server.LocalLeanManager">
            <summary>
            NOP implementation of the ILeanManager interface
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.Initialize(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.AlgorithmManager)">
            <summary>
            Empty implementation of the ILeanManager interface
            </summary>
            <param name="systemHandlers">Exposes lean engine system handlers running LEAN</param>
            <param name="algorithmHandlers">Exposes the lean algorithm handlers running lean</param>
            <param name="job">The job packet representing either a live or backtest Lean instance</param>
            <param name="algorithmManager">The Algorithm manager</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Sets the IAlgorithm instance in the ILeanManager
            </summary>
            <param name="algorithm">The IAlgorithm instance being run</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.Update">
            <summary>
            Update ILeanManager with the IAlgorithm instance
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.OnAlgorithmStart">
            <summary>
            This method is called after algorithm initialization
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.OnAlgorithmEnd">
            <summary>
            This method is called before algorithm termination
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Server.LocalLeanManager.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException">
            <summary>
            Defines an exception generated in the course of invoking <see cref="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException"/> class
            </summary>
            <param name="message">The error message</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Setup.AlgorithmSetupException"/> class
            </summary>
            <param name="message">The error message</param>
            <param name="inner">The inner exception being wrapped</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler">
            <summary>
            Backtesting setup handler processes the algorithm initialize method and sets up the internal state of the algorithm class.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Errors">
            <summary>
            Internal errors list from running the setup procedures.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.MaximumRuntime">
            <summary>
            Maximum runtime of the algorithm in seconds.
            </summary>
            <remarks>Maximum runtime is a formula based on the number and resolution of symbols requested, and the days backtesting</remarks>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.StartingPortfolioValue">
            <summary>
            Starting capital according to the users initialize routine.
            </summary>
            <remarks>Set from the user code.</remarks>
            <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.SetCash(System.Decimal)"/>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.StartingDate">
            <summary>
            Start date for analysis loops to search for data.
            </summary>
            <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.SetStartDate(System.DateTime)"/>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for this backtest.
            </summary>
            <remarks>To stop algorithm flooding the backtesting system with hundreds of megabytes of order data we limit it to 100 per day</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.#ctor">
            <summary>
            Initialize the backtest setup handler.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Brokerages.Backtesting.BacktestingBrokerage"/> instance
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Setup the algorithm cash, dates and data subscriptions as desired.
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>Boolean true on successfully initializing the algorithm</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.GetMaximumRuntime(System.DateTime,System.DateTime,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.UniverseManager,QuantConnect.Packets.Controls)">
            <summary>
            Calculate the maximum runtime for this algorithm job.
            </summary>
            <param name="start">State date of the algorithm</param>
            <param name="finish">End date of the algorithm</param>
            <param name="subscriptionManager">Subscription Manager</param>
            <param name="universeManager">Universe manager containing configured universes</param>
            <param name="controls">Job controls instance</param>
            <returns>Timespan maximum run period</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BaseSetupHandler">
            <summary>
             Base class that provides shared code for
            the <see cref="T:QuantConnect.Lean.Engine.Setup.ISetupHandler"/> implementations
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.SetupCurrencyConversions(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.UniverseSelection)">
            <summary>
            Will first check and add all the required conversion rate securities
            and later will seed an initial value to them.
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <param name="universeSelection">The universe selection instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.InitializeDebugging(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Util.WorkerThread)">
            <summary>
            Initialize the debugger
            </summary>
            <param name="algorithmNodePacket">The algorithm node packet</param>
            <param name="workerThread">The worker thread instance to use</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobCashAmount(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)">
            <summary>
            Sets the initial cash for the algorithm if set in the job packet.
            </summary>
            <remarks>Should be called after initialize <see cref="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobAccountCurrency(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)"/></remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobAccountCurrency(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)">
            <summary>
            Sets the account currency the algorithm should use if set in the job packet
            </summary>
            <remarks>Should be called before initialize <see cref="M:QuantConnect.Lean.Engine.Setup.BaseSetupHandler.LoadBacktestJobCashAmount(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.BacktestNodePacket)"/></remarks>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler">
            <summary>
            Defines a set up handler that initializes the algorithm instance using values retrieved from the user's brokerage account
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Errors">
            <summary>
            Any errors from the initialization stored here:
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaximumRuntime">
            <summary>
            Get the maximum runtime for this algorithm job.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.StartingPortfolioValue">
            <summary>
            Algorithm starting capital for statistics calculations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.StartingDate">
            <summary>
            Start date for analysis loops to search for data.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for the algorithm run -- applicable for backtests only.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.#ctor">
            <summary>
            Initializes a new BrokerageSetupHandler
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates the brokerage as specified by the job packet
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Primary entry point to setup a new algorithm
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>True on successfully setting up the algorithm state, or false on error.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.GetOpenOrders(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Interfaces.IBrokerage,System.Collections.Generic.HashSet{QuantConnect.SecurityType})">
            <summary>
            Get the open orders from a brokerage. Adds <see cref="T:QuantConnect.Orders.Order"/> and <see cref="T:QuantConnect.Orders.OrderTicket"/> to the transaction handler
            </summary>
            <param name="algorithm">Algorithm instance</param>
            <param name="resultHandler">The configured result handler</param>
            <param name="transactionHandler">The configurated transaction handler</param>
            <param name="brokerage">Brokerage output instance</param>
            <param name="supportedSecurityTypes">The list of supported security types</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.GetConfiguredDataFeeds">
            <summary>
            Get the available data feeds from config.json,
            If none available, throw an error
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.AddInitializationError(System.String,System.Exception)">
            <summary>
            Adds initialization error to the Errors list
            </summary>
            <param name="message">The error message to be added</param>
            <param name="inner">The inner exception being wrapped</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler">
            <summary>
            Console setup handler to initialize and setup the Lean Engine properties for a local backtest
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.Errors">
            <summary>
            Error which occured during setup may appear here.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.MaximumRuntime">
            <summary>
            Maximum runtime of the strategy. (Set to 10 years for local backtesting).
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.StartingPortfolioValue">
            <summary>
            Starting capital for the algorithm (Loaded from the algorithm code).
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.StartingDate">
            <summary>
            Start date for the backtest.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for this backtest.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.#ctor">
            <summary>
            Setup the algorithm data, cash, job start end date etc:
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Brokerages.Backtesting.BacktestingBrokerage"/> instance
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Setup the algorithm cash, dates and portfolio as desired.
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>Boolean true on successfully setting up the console.</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.GetConfiguredDataFeeds">
            <summary>
            Get the available data feeds from config.json,
            If none available, throw an error
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.MatchTypeName(System.String,System.String)">
            <summary>
            Matches type names as namespace qualified or just the name
            If expectedTypeName is null or empty, this will always return true
            </summary>
            <param name="currentTypeFullName"></param>
            <param name="expectedTypeName"></param>
            <returns>True on matching the type name</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.ISetupHandler">
            <summary>
            Interface to setup the algorithm. Pass in a raw algorithm, return one with portfolio, cash, etc already preset.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.WorkerThread">
            <summary>
            The worker thread instance the setup handler should use
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.Errors">
            <summary>
            Any errors from the initialization stored here:
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.MaximumRuntime">
            <summary>
            Get the maximum runtime for this algorithm job.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.StartingPortfolioValue">
            <summary>
            Algorithm starting capital for statistics calculations
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.StartingDate">
            <summary>
            Start date for analysis loops to search for data.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.MaxOrders">
            <summary>
            Maximum number of orders for the algorithm run -- applicable for backtests only.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.CreateAlgorithmInstance(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
            <summary>
            Create a new instance of an algorithm from a physical dll path.
            </summary>
            <param name="assemblyPath">The path to the assembly's location</param>
            <param name="algorithmNodePacket">Details of the task required</param>
            <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
            <summary>
            Creates the brokerage as specified by the job packet
            </summary>
            <param name="algorithmNodePacket">Job packet</param>
            <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
            <param name="factory">The brokerage factory</param>
            <returns>The brokerage instance, or throws if error creating instance</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.Setup(QuantConnect.Lean.Engine.Setup.SetupHandlerParameters)">
            <summary>
            Primary entry point to setup a new algorithm
            </summary>
            <param name="parameters">The parameters object to use</param>
            <returns>True on successfully setting up the algorithm state, or false on error.</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters">
            <summary>
            Defines the parameters for <see cref="T:QuantConnect.Lean.Engine.Setup.ISetupHandler"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.UniverseSelection">
            <summary>
            Gets the universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.Algorithm">
            <summary>
            Gets the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.Brokerage">
            <summary>
            Gets the Brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.AlgorithmNodePacket">
            <summary>
            Gets the algorithm node packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.ResultHandler">
            <summary>
            Gets the algorithm node packet
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.TransactionHandler">
            <summary>
            Gets the TransactionHandler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.RealTimeHandler">
            <summary>
            Gets the RealTimeHandler
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.ObjectStore">
            <summary>
            Gets the ObjectStore
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.SetupHandlerParameters.#ctor(QuantConnect.Lean.Engine.DataFeeds.UniverseSelection,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Interfaces.IObjectStore)">
            <summary>
            Creates a new instance
            </summary>
            <param name="universeSelection">The universe selection instance</param>
            <param name="algorithm">Algorithm instance</param>
            <param name="brokerage">New brokerage output instance</param>
            <param name="algorithmNodePacket">Algorithm job task</param>
            <param name="resultHandler">The configured result handler</param>
            <param name="transactionHandler">The configured transaction handler</param>
            <param name="realTimeHandler">The configured real time handler</param>
            <param name="objectStore">The configured object store</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Storage.LocalObjectStore">
            <summary>
            A local disk implementation of <see cref="T:QuantConnect.Interfaces.IObjectStore"/>.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Storage.LocalObjectStore.NoReadPermissionsError">
            <summary>
            No read permissions error message
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Storage.LocalObjectStore.NoWritePermissionsError">
            <summary>
            No write permissions error message
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ErrorRaised">
            <summary>
            Event raised each time there's an error
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.Storage.LocalObjectStore._dirty">
            <summary>
            Flag indicating the state of this object storage has changed since the last <seealso cref="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Persist"/> invocation
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Controls">
            <summary>
            Provides access to the controls governing behavior of this instance, such as the persistence interval
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.Storage.LocalObjectStore.AlgorithmStorageRoot">
            <summary>
            The root storage folder for the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Initialize(System.String,System.Int32,System.Int32,System.String,QuantConnect.Packets.Controls)">
            <summary>
            Initializes the object store
            </summary>
            <param name="algorithmName">The algorithm name</param>
            <param name="userId">The user id</param>
            <param name="projectId">The project id</param>
            <param name="userToken">The user token</param>
            <param name="controls">The job controls instance</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.LoadExistingObjects">
            <summary>
            Loads objects from the AlgorithmStorageRoot into the ObjectStore
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ContainsKey(System.String)">
            <summary>
            Determines whether the store contains data for the specified key
            </summary>
            <param name="key">The object key</param>
            <returns>True if the key was found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ReadBytes(System.String)">
            <summary>
            Returns the object data for the specified key
            </summary>
            <param name="key">The object key</param>
            <returns>A byte array containing the data</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.SaveBytes(System.String,System.Byte[])">
            <summary>
            Saves the object data for the specified key
            </summary>
            <param name="key">The object key</param>
            <param name="contents">The object data</param>
            <returns>True if the save operation was successful</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.InternalSaveBytes(System.String,System.Byte[])">
            <summary>
            Won't trigger persist nor will check storage write permissions, useful on initialization since it allows read only permissions to load the object store
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Delete(System.String)">
            <summary>
            Deletes the object data for the specified key
            </summary>
            <param name="key">The object key</param>
            <returns>True if the delete operation was successful</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.GetFilePath(System.String)">
            <summary>
            Returns the file path for the specified key
            </summary>
            <param name="key">The object key</param>
            <returns>The path for the file</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.PathForKey(System.String)">
            <summary>
            Get's a file path for a given key.
            Internal use only because it does not guarantee the existence of the file.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Persist">
            <summary>
            Invoked periodically to persist the object store's contents
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.PersistData(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Byte[]}})">
            <summary>
            Overridable persistence function
            </summary>
            <param name="data">The data to be persisted</param>
            <returns>True if persistence was successful, otherwise false</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.OnErrorRaised(System.Exception)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Lean.Engine.Storage.LocalObjectStore.ErrorRaised"/> event
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.BytesToMb(System.Int64)">
            <summary>
            Converts a number of bytes to megabytes as it's more human legible
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.KeyToBase64(System.String)">
            <summary>
            Convert a given key to a Base64 string
            </summary>
            <param name="key">Key to be encoded</param>
            <returns>Base64 hash string</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.LocalObjectStore.Base64ToKey(System.String)">
            <summary>
            Convert a given Base64 string back to a key
            </summary>
            <param name="hash">Hash to be decoded</param>
            <returns>Key string</returns>
        </member>
        <member name="T:QuantConnect.Lean.Engine.Storage.StorageLimitExceededException">
            <summary>
            Exception thrown when the object store storage limit has been exceeded
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.Storage.StorageLimitExceededException.#ctor(System.String)">
            <summary>
            Creates a new instance of the storage limit exceeded exception
            </summary>
            <param name="message">The associated message</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler">
            <summary>
            This transaction handler is used for processing transactions during backtests
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
            <summary>
            Creates a new BacktestingTransactionHandler using the BacktestingBrokerage
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <param name="brokerage">The BacktestingBrokerage</param>
            <param name="resultHandler"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessSynchronousEvents">
            <summary>
            Processes all synchronous events that must take place before the next time loop for the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessAsynchronousEvents">
            <summary>
            Processes asynchronous events on the transaction handler's thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.WaitForOrderSubmission(QuantConnect.Orders.OrderTicket)">
            <summary>
            For backtesting we will submit the order ourselves
            </summary>
            <param name="ticket">The <see cref="T:QuantConnect.Orders.OrderTicket"/> expecting to be submitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.InitializeTransactionThread">
            <summary>
            For backtesting order requests will be processed by the algorithm thread
            sequentially at <see cref="!:WaitForOrderToBeProcess"/> and <see cref="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessSynchronousEvents"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler">
            <summary>
            Transaction handler for all brokerages
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._orderRequestQueue">
            <summary>
            OrderQueue holds the newly updated orders from the user algorithm waiting to be processed. Once
            orders are processed they are moved into the Orders queue awaiting the brokerage response.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._completeOrders">
            <summary>
            The _completeOrders dictionary holds all orders.
            Once the transaction thread has worked on them they get put here while witing for fill updates.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._openOrders">
            <summary>
            The orders dictionary holds orders which are open. Status: New, Submitted, PartiallyFilled, None, CancelPending
            Once the transaction thread has worked on them they get put here while witing for fill updates.
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._openOrderTickets">
            <summary>
            The _openOrderTickets dictionary holds open order tickets that the algorithm can use to reference a specific order. This
            includes invoking update and cancel commands. In the future, we can add more features to the ticket, such as events
            and async events (such as run this code when this order fills)
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._completeOrderTickets">
            <summary>
            The _completeOrderTickets dictionary holds all order tickets that the algorithm can use to reference a specific order. This
            includes invoking update and cancel commands. In the future, we can add more features to the ticket, such as events
            and async events (such as run this code when this order fills)
            </summary>
        </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._cancelPendingOrders">
            <summary>
            The _cancelPendingOrders instance will help to keep track of CancelPending orders and their Status
            </summary>
        </member>
        <member name="E:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.NewOrderEvent">
            <summary>
            Event fired when there is a new <see cref="T:QuantConnect.Orders.OrderEvent"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Orders">
            <summary>
            Gets the permanent storage for all orders
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrderEvents">
            <summary>
            Gets all order events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrderTickets">
            <summary>
            Gets the permanent storage for all order tickets
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrdersCount">
            <summary>
            Gets the current number of orders that have been processed
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
            <summary>
            Creates a new BrokerageTransactionHandler to process orders using the specified brokerage implementation
            </summary>
            <param name="algorithm">The algorithm instance</param>
            <param name="brokerage">The brokerage implementation to process orders and fire fill events</param>
            <param name="resultHandler"></param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.InitializeTransactionThread">
            <summary>
            Create and start the transaction thread, who will be in charge of processing
            the order requests
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.IsActive">
            <summary>
            Boolean flag indicating the Run thread method is busy.
            False indicates it is completely finished processing and ready to be terminated.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Process(QuantConnect.Orders.OrderRequest)">
            <summary>
            Adds the specified order to be processed
            </summary>
            <param name="request">The order to be processed</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.AddOrder(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Add an order to collection and return the unique order id or negative if an error.
            </summary>
            <param name="request">A request detailing the order to be submitted</param>
            <returns>New unique, increasing orderid</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.WaitForOrderSubmission(QuantConnect.Orders.OrderTicket)">
            <summary>
            Wait for the order to be handled by the <see cref="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._processingThread"/>
            </summary>
            <param name="ticket">The <see cref="T:QuantConnect.Orders.OrderTicket"/> expecting to be submitted</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.UpdateOrder(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Update an order yet to be filled such as stop or limit orders.
            </summary>
            <param name="request">Request detailing how the order should be updated</param>
            <remarks>Does not apply if the order is already fully filled</remarks>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CancelOrder(QuantConnect.Orders.CancelOrderRequest)">
            <summary>
            Remove this order from outstanding queue: user is requesting a cancel.
            </summary>
            <param name="request">Request containing the specific order id to remove</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
            <summary>
            Gets and enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/>
            </summary>
            <param name="filter">The filter predicate used to find the required order tickets</param>
            <returns>An enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOpenOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
            <summary>
            Gets and enumerable of opened <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/>
            </summary>
            <param name="filter">The filter predicate used to find the required order tickets</param>
            <returns>An enumerable of opened <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderTicket(System.Int32)">
            <summary>
            Gets the order ticket for the specified order id. Returns null if not found
            </summary>
            <param name="orderId">The order's id</param>
            <returns>The order ticket with the specified id, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderById(System.Int32)">
            <summary>
            Get the order by its id
            </summary>
            <param name="orderId">Order id to fetch</param>
            <returns>A clone of the order with the specified id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderByBrokerageId(System.String)">
            <summary>
            Gets the order by its brokerage id
            </summary>
            <param name="brokerageId">The brokerage id to fetch</param>
            <returns>The first order matching the brokerage id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
            <summary>
            Gets all orders matching the specified filter. Specifying null will return an enumerable
            of all orders.
            </summary>
            <param name="filter">Delegate used to filter the orders</param>
            <returns>All orders this order provider currently holds by the specified filter</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOpenOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
            <summary>
            Gets open orders matching the specified filter
            </summary>
            <param name="filter">Delegate used to filter the orders</param>
            <returns>All open orders this order provider currently holds</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Run">
            <summary>
            Primary thread entry point to launch the transaction thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.ProcessAsynchronousEvents">
            <summary>
            Processes asynchronous events on the transaction handler's thread
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.ProcessSynchronousEvents">
            <summary>
            Processes all synchronous events that must take place before the next time loop for the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.AddOpenOrder(QuantConnect.Orders.Order,QuantConnect.Orders.OrderTicket)">
            <summary>
            Register an already open Order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Exit">
            <summary>
            Signal a end of thread request to stop monitoring the transactions.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleOrderRequest(QuantConnect.Orders.OrderRequest)">
            <summary>
            Handles a generic order request
            </summary>
            <param name="request"><see cref="T:QuantConnect.Orders.OrderRequest"/> to be handled</param>
            <returns><see cref="T:QuantConnect.Orders.OrderResponse"/> for request</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleSubmitOrderRequest(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Handles a request to submit a new order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Handles a request to update order properties
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CanUpdateOrder(QuantConnect.Orders.Order)">
            <summary>
            Returns true if the specified order can be updated
            </summary>
            <param name="order">The order to check if we can update</param>
            <returns>True if the order can be updated, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleCancelOrderRequest(QuantConnect.Orders.CancelOrderRequest)">
            <summary>
            Handles a request to cancel an order
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleAccountChanged(QuantConnect.Securities.AccountEvent)">
            <summary>
            Brokerages can send account updates, this include cash balance updates. Since it is of
            utmost important to always have an accurate picture of reality, we'll trust this information
            as truth
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandlePositionAssigned(QuantConnect.Orders.OrderEvent)">
            <summary>
            Option assignment/exercise event is received and propagated to the user algo
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.TimeSinceLastFill">
            <summary>
            Gets the amount of time since the last call to algorithm.Portfolio.ProcessFill(fill)
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CurrentTimeUtc">
            <summary>
            Gets current time UTC. This is here to facilitate testing
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOffOrder(QuantConnect.Orders.Order,QuantConnect.Securities.Security)">
            <summary>
            Rounds off the order towards 0 to the nearest multiple of Lot Size
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOrderPrices(QuantConnect.Orders.Order,QuantConnect.Securities.Security)">
            <summary>
            Rounds the order prices to its security minimum price variation.
            <remarks>
            This procedure is needed to meet brokerage precision requirements.
            </remarks>
            </summary>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders">
            <summary>
            Class used to keep track of CancelPending orders and their original or updated status
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.GetCancelPendingOrdersSize">
            <summary>
            Amount of CancelPending Orders
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.Set(System.Int32,QuantConnect.Orders.OrderStatus)">
            <summary>
            Adds an order which will be canceled and we want to keep track of it Status in case of fallback
            </summary>
            <param name="orderId">The order id</param>
            <param name="status">The order Status, before the cancel request</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.UpdateOrRemove(System.Int32,QuantConnect.Orders.OrderStatus)">
            <summary>
            Updates an order that is pending to be canceled.
            </summary>
            <param name="newStatus">The new status of the order. If its OrderStatus.Canceled or OrderStatus.Filled it will be removed</param>
            <param name="orderId">The id of the order</param>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.CancelPendingOrders.RemoveAndFallback(QuantConnect.Orders.Order)">
            <summary>
            Removes an order which we failed to cancel and falls back the order Status to previous value
            </summary>
            <param name="order">The order that failed to be canceled</param>
        </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler">
            <summary>
            Transaction handlers define how the transactions are processed and set the order fill information.
            The pass this information back to the algorithm portfolio and ensure the cash and portfolio are synchronized.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.IsActive">
            <summary>
            Boolean flag indicating the thread is busy.
            False indicates it is completely finished processing and ready to be terminated.
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Orders">
            <summary>
            Gets the permanent storage for all orders
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderEvents">
            <summary>
            Gets all order events
            </summary>
        </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.OrderTickets">
            <summary>
            Gets the permanent storage for all order tickets
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
            <summary>
            Initializes the transaction handler for the specified algorithm using the specified brokerage implementation
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Exit">
            <summary>
            Signal a end of thread request to stop montioring the transactions.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.ProcessSynchronousEvents">
            <summary>
            Process any synchronous events from the primary algorithm thread.
            </summary>
        </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.AddOpenOrder(QuantConnect.Orders.Order,QuantConnect.Orders.OrderTicket)">
            <summary>
            Register an already open Order
            </summary>
        </member>
    </members>
</doc>
